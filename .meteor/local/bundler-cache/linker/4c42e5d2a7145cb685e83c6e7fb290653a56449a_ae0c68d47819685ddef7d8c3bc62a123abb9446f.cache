[{"type":"js","data":"(function () {\n\n/* Imports */\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar meteorEnv = Package.meteor.meteorEnv;\nvar NpmModuleBcrypt = Package['npm-bcrypt'].NpmModuleBcrypt;\nvar Accounts = Package['accounts-base'].Accounts;\nvar SRP = Package.srp.SRP;\nvar SHA256 = Package.sha.SHA256;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar DDPServer = Package['ddp-server'].DDPServer;\nvar Email = Package.email.Email;\nvar EmailInternals = Package.email.EmailInternals;\nvar Random = Package.random.Random;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar _ = Package.underscore._;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar meteorInstall = Package.modules.meteorInstall;\nvar meteorBabelHelpers = Package['babel-runtime'].meteorBabelHelpers;\nvar Promise = Package.promise.Promise;\nvar Symbol = Package['ecmascript-runtime-server'].Symbol;\nvar Map = Package['ecmascript-runtime-server'].Map;\nvar Set = Package['ecmascript-runtime-server'].Set;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"accounts-password\":{\"email_templates.js\":function(){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/accounts-password/email_templates.js                                                                      //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nfunction greet(welcomeMsg) {                                                                                          // 1\n  return function (user, url) {                                                                                       // 2\n    var greeting = user.profile && user.profile.name ? \"Hello \" + user.profile.name + \",\" : \"Hello,\";                 // 3\n    return greeting + \"\\n\\n\" + welcomeMsg + \", simply click the link below.\\n\\n\" + url + \"\\n\\nThanks.\\n\";             // 5\n  };                                                                                                                  // 13\n} /**                                                                                                                 // 14\n   * @summary Options to customize emails sent from the Accounts system.                                              //\n   * @locus Server                                                                                                    //\n   * @importFromPackage accounts-base                                                                                 //\n   */                                                                                                                 //\n                                                                                                                      //\nAccounts.emailTemplates = {                                                                                           // 21\n  from: \"Accounts Example <no-reply@example.com>\",                                                                    // 22\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),                                      // 23\n  resetPassword: {                                                                                                    // 25\n    subject: function (user) {                                                                                        // 26\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;                                     // 27\n    },                                                                                                                // 28\n    text: greet(\"To reset your password\")                                                                             // 29\n  },                                                                                                                  // 25\n  verifyEmail: {                                                                                                      // 31\n    subject: function (user) {                                                                                        // 32\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;                                    // 33\n    },                                                                                                                // 34\n    text: greet(\"To verify your account email\")                                                                       // 35\n  },                                                                                                                  // 31\n  enrollAccount: {                                                                                                    // 37\n    subject: function (user) {                                                                                        // 38\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;                            // 39\n    },                                                                                                                // 40\n    text: greet(\"To start using the service\")                                                                         // 41\n  }                                                                                                                   // 37\n};                                                                                                                    // 21\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n},\"password_server.js\":function(require){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/accounts-password/password_server.js                                                                      //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\nvar _typeof2 = require(\"babel-runtime/helpers/typeof\");                                                               //\n                                                                                                                      //\nvar _typeof3 = _interopRequireDefault(_typeof2);                                                                      //\n                                                                                                                      //\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }                     //\n                                                                                                                      //\n/// BCRYPT                                                                                                            // 1\nvar bcrypt = NpmModuleBcrypt;                                                                                         // 3\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);                                                                       // 4\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare); // User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'                                                 // 8\n// field, in which case they will be upgraded to bcrypt the next time                                                 // 9\n// they log in).                                                                                                      // 10\n//                                                                                                                    // 11\n// When the client sends a password to the server, it can either be a                                                 // 12\n// string (the plaintext password) or an object with keys 'digest' and                                                // 13\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends                                            // 14\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients                                              // 15\n// that don't have access to SHA can just send plaintext passwords as                                                 // 16\n// strings.                                                                                                           // 17\n//                                                                                                                    // 18\n// When the server receives a plaintext password as a string, it always                                               // 19\n// hashes it with SHA256 before passing it into bcrypt. When the server                                               // 20\n// receives a password as an object, it asserts that the algorithm is                                                 // 21\n// \"sha-256\" and then passes the digest to bcrypt.                                                                    // 22\n                                                                                                                      //\nAccounts._bcryptRounds = 10; // Given a 'password' from the client, extract the string that we should                 // 25\n// bcrypt. 'password' can be one of:                                                                                  // 28\n//  - String (the plaintext password)                                                                                 // 29\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".                                       // 30\n//                                                                                                                    // 31\n                                                                                                                      //\nvar getPasswordString = function (password) {                                                                         // 32\n  if (typeof password === \"string\") {                                                                                 // 33\n    password = SHA256(password);                                                                                      // 34\n  } else {                                                                                                            // 35\n    // 'password' is an object                                                                                        // 35\n    if (password.algorithm !== \"sha-256\") {                                                                           // 36\n      throw new Error(\"Invalid password hash algorithm. \" + \"Only 'sha-256' is allowed.\");                            // 37\n    }                                                                                                                 // 39\n                                                                                                                      //\n    password = password.digest;                                                                                       // 40\n  }                                                                                                                   // 41\n                                                                                                                      //\n  return password;                                                                                                    // 42\n}; // Use bcrypt to hash the password for storage in the database.                                                    // 43\n// `password` can be a string (in which case it will be run through                                                   // 46\n// SHA256 before bcrypt) or an object with properties `digest` and                                                    // 47\n// `algorithm` (in which case we bcrypt `password.digest`).                                                           // 48\n//                                                                                                                    // 49\n                                                                                                                      //\n                                                                                                                      //\nvar hashPassword = function (password) {                                                                              // 50\n  password = getPasswordString(password);                                                                             // 51\n  return bcryptHash(password, Accounts._bcryptRounds);                                                                // 52\n}; // Check whether the provided password matches the bcrypt'ed password in                                           // 53\n// the database user record. `password` can be a string (in which case                                                // 56\n// it will be run through SHA256 before bcrypt) or an object with                                                     // 57\n// properties `digest` and `algorithm` (in which case we bcrypt                                                       // 58\n// `password.digest`).                                                                                                // 59\n//                                                                                                                    // 60\n                                                                                                                      //\n                                                                                                                      //\nAccounts._checkPassword = function (user, password) {                                                                 // 61\n  var result = {                                                                                                      // 62\n    userId: user._id                                                                                                  // 63\n  };                                                                                                                  // 62\n  password = getPasswordString(password);                                                                             // 66\n                                                                                                                      //\n  if (!bcryptCompare(password, user.services.password.bcrypt)) {                                                      // 68\n    result.error = handleError(\"Incorrect password\", false);                                                          // 69\n  }                                                                                                                   // 70\n                                                                                                                      //\n  return result;                                                                                                      // 72\n};                                                                                                                    // 73\n                                                                                                                      //\nvar checkPassword = Accounts._checkPassword; ///                                                                      // 74\n/// ERROR HANDLER                                                                                                     // 77\n///                                                                                                                   // 78\n                                                                                                                      //\nvar handleError = function (msg) {                                                                                    // 79\n  var throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;                          // 79\n  var error = new Meteor.Error(403, Accounts._options.ambiguousErrorMessages ? \"Something went wrong. Please check your credentials.\" : msg);\n                                                                                                                      //\n  if (throwError) {                                                                                                   // 86\n    throw error;                                                                                                      // 87\n  }                                                                                                                   // 88\n                                                                                                                      //\n  return error;                                                                                                       // 89\n}; ///                                                                                                                // 90\n/// LOGIN                                                                                                             // 93\n///                                                                                                                   // 94\n                                                                                                                      //\n                                                                                                                      //\nAccounts._findUserByQuery = function (query) {                                                                        // 96\n  var user = null;                                                                                                    // 97\n                                                                                                                      //\n  if (query.id) {                                                                                                     // 99\n    user = Meteor.users.findOne({                                                                                     // 100\n      _id: query.id                                                                                                   // 100\n    });                                                                                                               // 100\n  } else {                                                                                                            // 101\n    var fieldName;                                                                                                    // 102\n    var fieldValue;                                                                                                   // 103\n                                                                                                                      //\n    if (query.username) {                                                                                             // 104\n      fieldName = 'username';                                                                                         // 105\n      fieldValue = query.username;                                                                                    // 106\n    } else if (query.email) {                                                                                         // 107\n      fieldName = 'emails.address';                                                                                   // 108\n      fieldValue = query.email;                                                                                       // 109\n    } else {                                                                                                          // 110\n      throw new Error(\"shouldn't happen (validation missed something)\");                                              // 111\n    }                                                                                                                 // 112\n                                                                                                                      //\n    var selector = {};                                                                                                // 113\n    selector[fieldName] = fieldValue;                                                                                 // 114\n    user = Meteor.users.findOne(selector); // If user is not found, try a case insensitive lookup                     // 115\n                                                                                                                      //\n    if (!user) {                                                                                                      // 117\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);                                         // 118\n      var candidateUsers = Meteor.users.find(selector).fetch(); // No match if multiple candidates are found          // 119\n                                                                                                                      //\n      if (candidateUsers.length === 1) {                                                                              // 121\n        user = candidateUsers[0];                                                                                     // 122\n      }                                                                                                               // 123\n    }                                                                                                                 // 124\n  }                                                                                                                   // 125\n                                                                                                                      //\n  return user;                                                                                                        // 127\n}; /**                                                                                                                // 128\n    * @summary Finds the user with the specified username.                                                            //\n    * First tries to match username case sensitively; if that fails, it                                               //\n    * tries case insensitively; but if more than one user matches the case                                            //\n    * insensitive search, it returns null.                                                                            //\n    * @locus Server                                                                                                   //\n    * @param {String} username The username to look for                                                               //\n    * @returns {Object} A user if found, else null                                                                    //\n    * @importFromPackage accounts-base                                                                                //\n    */                                                                                                                //\n                                                                                                                      //\nAccounts.findUserByUsername = function (username) {                                                                   // 140\n  return Accounts._findUserByQuery({                                                                                  // 141\n    username: username                                                                                                // 142\n  });                                                                                                                 // 141\n}; /**                                                                                                                // 144\n    * @summary Finds the user with the specified email.                                                               //\n    * First tries to match email case sensitively; if that fails, it                                                  //\n    * tries case insensitively; but if more than one user matches the case                                            //\n    * insensitive search, it returns null.                                                                            //\n    * @locus Server                                                                                                   //\n    * @param {String} email The email address to look for                                                             //\n    * @returns {Object} A user if found, else null                                                                    //\n    * @importFromPackage accounts-base                                                                                //\n    */                                                                                                                //\n                                                                                                                      //\nAccounts.findUserByEmail = function (email) {                                                                         // 156\n  return Accounts._findUserByQuery({                                                                                  // 157\n    email: email                                                                                                      // 158\n  });                                                                                                                 // 157\n}; // Generates a MongoDB selector that can be used to perform a fast case                                            // 160\n// insensitive lookup for the given fieldName and string. Since MongoDB does                                          // 163\n// not support case insensitive indexes, and case insensitive regex queries                                           // 164\n// are slow, we construct a set of prefix selectors for all permutations of                                           // 165\n// the first 4 characters ourselves. We first attempt to matching against                                             // 166\n// these, and because 'prefix expression' regex queries do use indexes (see                                           // 167\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),                                           // 168\n// this has been found to greatly improve performance (from 1200ms to 5ms in a                                        // 169\n// test with 1.000.000 users).                                                                                        // 170\n                                                                                                                      //\n                                                                                                                      //\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {                                             // 171\n  // Performance seems to improve up to 4 prefix characters                                                           // 172\n  var prefix = string.substring(0, Math.min(string.length, 4));                                                       // 173\n                                                                                                                      //\n  var orClause = _.map(generateCasePermutationsForString(prefix), function (prefixPermutation) {                      // 174\n    var selector = {};                                                                                                // 176\n    selector[fieldName] = new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));                                  // 177\n    return selector;                                                                                                  // 179\n  });                                                                                                                 // 180\n                                                                                                                      //\n  var caseInsensitiveClause = {};                                                                                     // 181\n  caseInsensitiveClause[fieldName] = new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i');                       // 182\n  return {                                                                                                            // 184\n    $and: [{                                                                                                          // 184\n      $or: orClause                                                                                                   // 184\n    }, caseInsensitiveClause]                                                                                         // 184\n  };                                                                                                                  // 184\n}; // Generates permutations of all case variations of a given string.                                                // 185\n                                                                                                                      //\n                                                                                                                      //\nvar generateCasePermutationsForString = function (string) {                                                           // 188\n  var permutations = [''];                                                                                            // 189\n                                                                                                                      //\n  for (var i = 0; i < string.length; i++) {                                                                           // 190\n    var ch = string.charAt(i);                                                                                        // 191\n    permutations = _.flatten(_.map(permutations, function (prefix) {                                                  // 192\n      var lowerCaseChar = ch.toLowerCase();                                                                           // 193\n      var upperCaseChar = ch.toUpperCase(); // Don't add unneccesary permutations when ch is not a letter             // 194\n                                                                                                                      //\n      if (lowerCaseChar === upperCaseChar) {                                                                          // 196\n        return [prefix + ch];                                                                                         // 197\n      } else {                                                                                                        // 198\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];                                                      // 199\n      }                                                                                                               // 200\n    }));                                                                                                              // 201\n  }                                                                                                                   // 202\n                                                                                                                      //\n  return permutations;                                                                                                // 203\n};                                                                                                                    // 204\n                                                                                                                      //\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {                    // 206\n  // Some tests need the ability to add users with the same case insensitive                                          // 207\n  // value, hence the _skipCaseInsensitiveChecksForTest check                                                         // 208\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);                                      // 209\n                                                                                                                      //\n  if (fieldValue && !skipCheck) {                                                                                     // 211\n    var matchedUsers = Meteor.users.find(selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();        // 212\n                                                                                                                      //\n    if (matchedUsers.length > 0 && ( // If we don't have a userId yet, any match we find is a duplicate               // 215\n    !ownUserId || // Otherwise, check to see if there are multiple matches or a match                                 // 217\n    // that is not us                                                                                                 // 219\n    matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)) {                                                  // 220\n      handleError(displayName + \" already exists.\");                                                                  // 221\n    }                                                                                                                 // 222\n  }                                                                                                                   // 223\n}; // XXX maybe this belongs in the check package                                                                     // 224\n                                                                                                                      //\n                                                                                                                      //\nvar NonEmptyString = Match.Where(function (x) {                                                                       // 227\n  check(x, String);                                                                                                   // 228\n  return x.length > 0;                                                                                                // 229\n});                                                                                                                   // 230\nvar userQueryValidator = Match.Where(function (user) {                                                                // 232\n  check(user, {                                                                                                       // 233\n    id: Match.Optional(NonEmptyString),                                                                               // 234\n    username: Match.Optional(NonEmptyString),                                                                         // 235\n    email: Match.Optional(NonEmptyString)                                                                             // 236\n  });                                                                                                                 // 233\n  if (_.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");                  // 238\n  return true;                                                                                                        // 240\n});                                                                                                                   // 241\nvar passwordValidator = Match.OneOf(String, {                                                                         // 243\n  digest: String,                                                                                                     // 245\n  algorithm: String                                                                                                   // 245\n}); // Handler to login with a password.                                                                              // 245\n//                                                                                                                    // 249\n// The Meteor client sets options.password to an object with keys                                                     // 250\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").                                                    // 251\n//                                                                                                                    // 252\n// For other DDP clients which don't have access to SHA, the handler                                                  // 253\n// also accepts the plaintext password in options.password as a string.                                               // 254\n//                                                                                                                    // 255\n// (It might be nice if servers could turn the plaintext password                                                     // 256\n// option off. Or maybe it should be opt-in, not opt-out?                                                             // 257\n// Accounts.config option?)                                                                                           // 258\n//                                                                                                                    // 259\n// Note that neither password option is secure without SSL.                                                           // 260\n//                                                                                                                    // 261\n                                                                                                                      //\nAccounts.registerLoginHandler(\"password\", function (options) {                                                        // 262\n  if (!options.password || options.srp) return undefined; // don't handle                                             // 263\n                                                                                                                      //\n  check(options, {                                                                                                    // 266\n    user: userQueryValidator,                                                                                         // 267\n    password: passwordValidator                                                                                       // 268\n  });                                                                                                                 // 266\n                                                                                                                      //\n  var user = Accounts._findUserByQuery(options.user);                                                                 // 272\n                                                                                                                      //\n  if (!user) {                                                                                                        // 273\n    handleError(\"User not found\");                                                                                    // 274\n  }                                                                                                                   // 275\n                                                                                                                      //\n  if (!user.services || !user.services.password || !(user.services.password.bcrypt || user.services.password.srp)) {  // 277\n    handleError(\"User has no password set\");                                                                          // 279\n  }                                                                                                                   // 280\n                                                                                                                      //\n  if (!user.services.password.bcrypt) {                                                                               // 282\n    if (typeof options.password === \"string\") {                                                                       // 283\n      // The client has presented a plaintext password, and the user is                                               // 284\n      // not upgraded to bcrypt yet. We don't attempt to tell the client                                              // 285\n      // to upgrade to bcrypt, because it might be a standalone DDP                                                   // 286\n      // client doesn't know how to do such a thing.                                                                  // 287\n      var verifier = user.services.password.srp;                                                                      // 288\n      var newVerifier = SRP.generateVerifier(options.password, {                                                      // 289\n        identity: verifier.identity,                                                                                  // 290\n        salt: verifier.salt                                                                                           // 290\n      });                                                                                                             // 289\n                                                                                                                      //\n      if (verifier.verifier !== newVerifier.verifier) {                                                               // 292\n        return {                                                                                                      // 293\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,                                         // 294\n          error: handleError(\"Incorrect password\", false)                                                             // 295\n        };                                                                                                            // 293\n      }                                                                                                               // 297\n                                                                                                                      //\n      return {                                                                                                        // 299\n        userId: user._id                                                                                              // 299\n      };                                                                                                              // 299\n    } else {                                                                                                          // 300\n      // Tell the client to use the SRP upgrade process.                                                              // 301\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                            // 302\n        format: 'srp',                                                                                                // 303\n        identity: user.services.password.srp.identity                                                                 // 304\n      }));                                                                                                            // 302\n    }                                                                                                                 // 306\n  }                                                                                                                   // 307\n                                                                                                                      //\n  return checkPassword(user, options.password);                                                                       // 309\n}); // Handler to login using the SRP upgrade path. To use this login                                                 // 313\n// handler, the client must provide:                                                                                  // 316\n//   - srp: H(identity + \":\" + password)                                                                              // 317\n//   - password: a string or an object with properties 'digest' and 'algorithm'                                       // 318\n//                                                                                                                    // 319\n// We use `options.srp` to verify that the client knows the correct                                                   // 320\n// password without doing a full SRP flow. Once we've checked that, we                                                // 321\n// upgrade the user to bcrypt and remove the SRP information from the                                                 // 322\n// user document.                                                                                                     // 323\n//                                                                                                                    // 324\n// The client ends up using this login handler after trying the normal                                                // 325\n// login handler (above), which throws an error telling the client to                                                 // 326\n// try the SRP upgrade path.                                                                                          // 327\n//                                                                                                                    // 328\n// XXX COMPAT WITH 0.8.1.3                                                                                            // 329\n                                                                                                                      //\nAccounts.registerLoginHandler(\"password\", function (options) {                                                        // 330\n  if (!options.srp || !options.password) {                                                                            // 331\n    return undefined; // don't handle                                                                                 // 332\n  }                                                                                                                   // 333\n                                                                                                                      //\n  check(options, {                                                                                                    // 335\n    user: userQueryValidator,                                                                                         // 336\n    srp: String,                                                                                                      // 337\n    password: passwordValidator                                                                                       // 338\n  });                                                                                                                 // 335\n                                                                                                                      //\n  var user = Accounts._findUserByQuery(options.user);                                                                 // 341\n                                                                                                                      //\n  if (!user) {                                                                                                        // 342\n    handleError(\"User not found\");                                                                                    // 343\n  } // Check to see if another simultaneous login has already upgraded                                                // 344\n  // the user record to bcrypt.                                                                                       // 347\n                                                                                                                      //\n                                                                                                                      //\n  if (user.services && user.services.password && user.services.password.bcrypt) {                                     // 348\n    return checkPassword(user, options.password);                                                                     // 349\n  }                                                                                                                   // 350\n                                                                                                                      //\n  if (!(user.services && user.services.password && user.services.password.srp)) {                                     // 352\n    handleError(\"User has no password set\");                                                                          // 353\n  }                                                                                                                   // 354\n                                                                                                                      //\n  var v1 = user.services.password.srp.verifier;                                                                       // 356\n  var v2 = SRP.generateVerifier(null, {                                                                               // 357\n    hashedIdentityAndPassword: options.srp,                                                                           // 360\n    salt: user.services.password.srp.salt                                                                             // 361\n  }).verifier;                                                                                                        // 359\n                                                                                                                      //\n  if (v1 !== v2) {                                                                                                    // 364\n    return {                                                                                                          // 365\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,                                             // 366\n      error: handleError(\"Incorrect password\", false)                                                                 // 367\n    };                                                                                                                // 365\n  } // Upgrade to bcrypt on successful login.                                                                         // 369\n                                                                                                                      //\n                                                                                                                      //\n  var salted = hashPassword(options.password);                                                                        // 372\n  Meteor.users.update(user._id, {                                                                                     // 373\n    $unset: {                                                                                                         // 376\n      'services.password.srp': 1                                                                                      // 376\n    },                                                                                                                // 376\n    $set: {                                                                                                           // 377\n      'services.password.bcrypt': salted                                                                              // 377\n    }                                                                                                                 // 377\n  });                                                                                                                 // 375\n  return {                                                                                                            // 381\n    userId: user._id                                                                                                  // 381\n  };                                                                                                                  // 381\n}); ///                                                                                                               // 382\n/// CHANGING                                                                                                          // 386\n///                                                                                                                   // 387\n/**                                                                                                                   // 389\n * @summary Change a user's username. Use this instead of updating the                                                //\n * database directly. The operation will fail if there is an existing user                                            //\n * with a username only differing in case.                                                                            //\n * @locus Server                                                                                                      //\n * @param {String} userId The ID of the user to update.                                                               //\n * @param {String} newUsername A new username for the user.                                                           //\n * @importFromPackage accounts-base                                                                                   //\n */                                                                                                                   //\n                                                                                                                      //\nAccounts.setUsername = function (userId, newUsername) {                                                               // 398\n  check(userId, NonEmptyString);                                                                                      // 399\n  check(newUsername, NonEmptyString);                                                                                 // 400\n  var user = Meteor.users.findOne(userId);                                                                            // 402\n                                                                                                                      //\n  if (!user) {                                                                                                        // 403\n    handleError(\"User not found\");                                                                                    // 404\n  }                                                                                                                   // 405\n                                                                                                                      //\n  var oldUsername = user.username; // Perform a case insensitive check for duplicates before update                   // 407\n                                                                                                                      //\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                   // 410\n  Meteor.users.update({                                                                                               // 412\n    _id: user._id                                                                                                     // 412\n  }, {                                                                                                                // 412\n    $set: {                                                                                                           // 412\n      username: newUsername                                                                                           // 412\n    }                                                                                                                 // 412\n  }); // Perform another check after update, in case a matching user has been                                         // 412\n  // inserted in the meantime                                                                                         // 415\n                                                                                                                      //\n  try {                                                                                                               // 416\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);                                 // 417\n  } catch (ex) {                                                                                                      // 418\n    // Undo update if the check fails                                                                                 // 419\n    Meteor.users.update({                                                                                             // 420\n      _id: user._id                                                                                                   // 420\n    }, {                                                                                                              // 420\n      $set: {                                                                                                         // 420\n        username: oldUsername                                                                                         // 420\n      }                                                                                                               // 420\n    });                                                                                                               // 420\n    throw ex;                                                                                                         // 421\n  }                                                                                                                   // 422\n}; // Let the user change their own password if they know the old                                                     // 423\n// password. `oldPassword` and `newPassword` should be objects with keys                                              // 426\n// `digest` and `algorithm` (representing the SHA256 of the password).                                                // 427\n//                                                                                                                    // 428\n// XXX COMPAT WITH 0.8.1.3                                                                                            // 429\n// Like the login method, if the user hasn't been upgraded from SRP to                                                // 430\n// bcrypt yet, then this method will throw an 'old password format'                                                   // 431\n// error. The client should call the SRP upgrade login handler and then                                               // 432\n// retry this method again.                                                                                           // 433\n//                                                                                                                    // 434\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade                                              // 435\n// errors thrown. The reasoning for this is that clients using this                                                   // 436\n// method directly will need to be updated anyway because we no longer                                                // 437\n// support the SRP flow that they would have been doing to use this                                                   // 438\n// method previously.                                                                                                 // 439\n                                                                                                                      //\n                                                                                                                      //\nMeteor.methods({                                                                                                      // 440\n  changePassword: function (oldPassword, newPassword) {                                                               // 440\n    check(oldPassword, passwordValidator);                                                                            // 441\n    check(newPassword, passwordValidator);                                                                            // 442\n                                                                                                                      //\n    if (!this.userId) {                                                                                               // 444\n      throw new Meteor.Error(401, \"Must be logged in\");                                                               // 445\n    }                                                                                                                 // 446\n                                                                                                                      //\n    var user = Meteor.users.findOne(this.userId);                                                                     // 448\n                                                                                                                      //\n    if (!user) {                                                                                                      // 449\n      handleError(\"User not found\");                                                                                  // 450\n    }                                                                                                                 // 451\n                                                                                                                      //\n    if (!user.services || !user.services.password || !user.services.password.bcrypt && !user.services.password.srp) {\n      handleError(\"User has no password set\");                                                                        // 455\n    }                                                                                                                 // 456\n                                                                                                                      //\n    if (!user.services.password.bcrypt) {                                                                             // 458\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({                                            // 459\n        format: 'srp',                                                                                                // 460\n        identity: user.services.password.srp.identity                                                                 // 461\n      }));                                                                                                            // 459\n    }                                                                                                                 // 463\n                                                                                                                      //\n    var result = checkPassword(user, oldPassword);                                                                    // 465\n                                                                                                                      //\n    if (result.error) {                                                                                               // 466\n      throw result.error;                                                                                             // 467\n    }                                                                                                                 // 468\n                                                                                                                      //\n    var hashed = hashPassword(newPassword); // It would be better if this removed ALL existing tokens and replaced    // 470\n    // the token for the current connection with a new one, but that would                                            // 473\n    // be tricky, so we'll settle for just replacing all tokens other than                                            // 474\n    // the one for the current connection.                                                                            // 475\n                                                                                                                      //\n    var currentToken = Accounts._getLoginToken(this.connection.id);                                                   // 476\n                                                                                                                      //\n    Meteor.users.update({                                                                                             // 477\n      _id: this.userId                                                                                                // 478\n    }, {                                                                                                              // 478\n      $set: {                                                                                                         // 480\n        'services.password.bcrypt': hashed                                                                            // 480\n      },                                                                                                              // 480\n      $pull: {                                                                                                        // 481\n        'services.resume.loginTokens': {                                                                              // 482\n          hashedToken: {                                                                                              // 482\n            $ne: currentToken                                                                                         // 482\n          }                                                                                                           // 482\n        }                                                                                                             // 482\n      },                                                                                                              // 481\n      $unset: {                                                                                                       // 484\n        'services.password.reset': 1                                                                                  // 484\n      }                                                                                                               // 484\n    });                                                                                                               // 479\n    return {                                                                                                          // 488\n      passwordChanged: true                                                                                           // 488\n    };                                                                                                                // 488\n  }                                                                                                                   // 489\n}); // Force change the users password.                                                                               // 440\n/**                                                                                                                   // 494\n * @summary Forcibly change the password for a user.                                                                  //\n * @locus Server                                                                                                      //\n * @param {String} userId The id of the user to update.                                                               //\n * @param {String} newPassword A new password for the user.                                                           //\n * @param {Object} [options]                                                                                          //\n * @param {Object} options.logout Logout all current connections with this userId (default: true)                     //\n * @importFromPackage accounts-base                                                                                   //\n */                                                                                                                   //\n                                                                                                                      //\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {                                             // 503\n  options = _.extend({                                                                                                // 504\n    logout: true                                                                                                      // 504\n  }, options);                                                                                                        // 504\n  var user = Meteor.users.findOne(userId);                                                                            // 506\n                                                                                                                      //\n  if (!user) {                                                                                                        // 507\n    throw new Meteor.Error(403, \"User not found\");                                                                    // 508\n  }                                                                                                                   // 509\n                                                                                                                      //\n  var update = {                                                                                                      // 511\n    $unset: {                                                                                                         // 512\n      'services.password.srp': 1,                                                                                     // 513\n      // XXX COMPAT WITH 0.8.1.3                                                                                      // 513\n      'services.password.reset': 1                                                                                    // 514\n    },                                                                                                                // 512\n    $set: {                                                                                                           // 516\n      'services.password.bcrypt': hashPassword(newPlaintextPassword)                                                  // 516\n    }                                                                                                                 // 516\n  };                                                                                                                  // 511\n                                                                                                                      //\n  if (options.logout) {                                                                                               // 519\n    update.$unset['services.resume.loginTokens'] = 1;                                                                 // 520\n  }                                                                                                                   // 521\n                                                                                                                      //\n  Meteor.users.update({                                                                                               // 523\n    _id: user._id                                                                                                     // 523\n  }, update);                                                                                                         // 523\n}; ///                                                                                                                // 524\n/// RESETTING VIA EMAIL                                                                                               // 528\n///                                                                                                                   // 529\n// Method called by a user to request a password reset email. This is                                                 // 531\n// the start of the reset process.                                                                                    // 532\n                                                                                                                      //\n                                                                                                                      //\nMeteor.methods({                                                                                                      // 533\n  forgotPassword: function (options) {                                                                                // 533\n    check(options, {                                                                                                  // 534\n      email: String                                                                                                   // 534\n    });                                                                                                               // 534\n    var user = Accounts.findUserByEmail(options.email);                                                               // 536\n                                                                                                                      //\n    if (!user) {                                                                                                      // 537\n      handleError(\"User not found\");                                                                                  // 538\n    }                                                                                                                 // 539\n                                                                                                                      //\n    var emails = _.pluck(user.emails || [], 'address');                                                               // 541\n                                                                                                                      //\n    var caseSensitiveEmail = _.find(emails, function (email) {                                                        // 542\n      return email.toLowerCase() === options.email.toLowerCase();                                                     // 543\n    });                                                                                                               // 544\n                                                                                                                      //\n    Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);                                                    // 546\n  }                                                                                                                   // 547\n}); /**                                                                                                               // 533\n     * @summary Generates a reset token and saves it into the database.                                               //\n     * @locus Server                                                                                                  //\n     * @param {String} userId The id of the user to generate the reset token for.                                     //\n     * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n     * @param {String} reason `resetPassword` or `enrollAccount`.                                                     //\n     * @param {Object} [extraTokenData] Optional additional data to be added into the token record.                   //\n     * @returns {Object} Object with {email, user, token} values.                                                     //\n     * @importFromPackage accounts-base                                                                               //\n     */                                                                                                               //\n                                                                                                                      //\nAccounts.generateResetToken = function (userId, email, reason, extraTokenData) {                                      // 559\n  // Make sure the user exists, and email is one of their addresses.                                                  // 560\n  var user = Meteor.users.findOne(userId);                                                                            // 561\n                                                                                                                      //\n  if (!user) {                                                                                                        // 562\n    handleError(\"Can't find user\");                                                                                   // 563\n  } // pick the first email if we weren't passed an email.                                                            // 564\n                                                                                                                      //\n                                                                                                                      //\n  if (!email && user.emails && user.emails[0]) {                                                                      // 567\n    email = user.emails[0].address;                                                                                   // 568\n  } // make sure we have a valid email                                                                                // 569\n                                                                                                                      //\n                                                                                                                      //\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {                                          // 572\n    handleError(\"No such email for user.\");                                                                           // 573\n  }                                                                                                                   // 574\n                                                                                                                      //\n  var token = Random.secret();                                                                                        // 576\n  var tokenRecord = {                                                                                                 // 577\n    token: token,                                                                                                     // 578\n    email: email,                                                                                                     // 579\n    when: new Date()                                                                                                  // 580\n  };                                                                                                                  // 577\n                                                                                                                      //\n  if (reason === 'resetPassword') {                                                                                   // 583\n    tokenRecord.reason = 'reset';                                                                                     // 584\n  } else if (reason === 'enrollAccount') {                                                                            // 585\n    tokenRecord.reason = 'enroll';                                                                                    // 586\n  } else if (reason) {                                                                                                // 587\n    // fallback so that this function can be used for unknown reasons as well                                         // 588\n    tokenRecord.reason = reason;                                                                                      // 589\n  }                                                                                                                   // 590\n                                                                                                                      //\n  if (extraTokenData) {                                                                                               // 592\n    _.extend(tokenRecord, extraTokenData);                                                                            // 593\n  }                                                                                                                   // 594\n                                                                                                                      //\n  Meteor.users.update({                                                                                               // 596\n    _id: user._id                                                                                                     // 596\n  }, {                                                                                                                // 596\n    $set: {                                                                                                           // 596\n      'services.password.reset': tokenRecord                                                                          // 597\n    }                                                                                                                 // 596\n  }); // before passing to template, update user object with new token                                                // 596\n                                                                                                                      //\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;                                                   // 601\n  return {                                                                                                            // 603\n    email: email,                                                                                                     // 603\n    user: user,                                                                                                       // 603\n    token: token                                                                                                      // 603\n  };                                                                                                                  // 603\n}; /**                                                                                                                // 604\n    * @summary Generates an e-mail verification token and saves it into the database.                                 //\n    * @locus Server                                                                                                   //\n    * @param {String} userId The id of the user to generate the  e-mail verification token for.                       //\n    * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n    * @param {Object} [extraTokenData] Optional additional data to be added into the token record.                    //\n    * @returns {Object} Object with {email, user, token} values.                                                      //\n    * @importFromPackage accounts-base                                                                                //\n    */                                                                                                                //\n                                                                                                                      //\nAccounts.generateVerificationToken = function (userId, email, extraTokenData) {                                       // 615\n  // Make sure the user exists, and email is one of their addresses.                                                  // 616\n  var user = Meteor.users.findOne(userId);                                                                            // 617\n                                                                                                                      //\n  if (!user) {                                                                                                        // 618\n    handleError(\"Can't find user\");                                                                                   // 619\n  } // pick the first unverified email if we weren't passed an email.                                                 // 620\n                                                                                                                      //\n                                                                                                                      //\n  if (!email) {                                                                                                       // 623\n    var emailRecord = _.find(user.emails || [], function (e) {                                                        // 624\n      return !e.verified;                                                                                             // 624\n    });                                                                                                               // 624\n                                                                                                                      //\n    email = (emailRecord || {}).address;                                                                              // 625\n                                                                                                                      //\n    if (!email) {                                                                                                     // 627\n      handleError(\"That user has no unverified email addresses.\");                                                    // 628\n    }                                                                                                                 // 629\n  } // make sure we have a valid email                                                                                // 630\n                                                                                                                      //\n                                                                                                                      //\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {                                          // 633\n    handleError(\"No such email for user.\");                                                                           // 634\n  }                                                                                                                   // 635\n                                                                                                                      //\n  var token = Random.secret();                                                                                        // 637\n  var tokenRecord = {                                                                                                 // 638\n    token: token,                                                                                                     // 639\n    // TODO: This should probably be renamed to \"email\" to match reset token record.                                  // 640\n    address: email,                                                                                                   // 641\n    when: new Date()                                                                                                  // 642\n  };                                                                                                                  // 638\n                                                                                                                      //\n  if (extraTokenData) {                                                                                               // 645\n    _.extend(tokenRecord, extraTokenData);                                                                            // 646\n  }                                                                                                                   // 647\n                                                                                                                      //\n  Meteor.users.update({                                                                                               // 649\n    _id: user._id                                                                                                     // 649\n  }, {                                                                                                                // 649\n    $push: {                                                                                                          // 649\n      'services.email.verificationTokens': tokenRecord                                                                // 650\n    }                                                                                                                 // 649\n  }); // before passing to template, update user object with new token                                                // 649\n                                                                                                                      //\n  Meteor._ensure(user, 'services', 'email');                                                                          // 654\n                                                                                                                      //\n  if (!user.services.email.verificationTokens) {                                                                      // 655\n    user.services.email.verificationTokens = [];                                                                      // 656\n  }                                                                                                                   // 657\n                                                                                                                      //\n  user.services.email.verificationTokens.push(tokenRecord);                                                           // 658\n  return {                                                                                                            // 660\n    email: email,                                                                                                     // 660\n    user: user,                                                                                                       // 660\n    token: token                                                                                                      // 660\n  };                                                                                                                  // 660\n}; /**                                                                                                                // 661\n    * @summary Creates options for email sending for reset password and enroll account emails.                        //\n    * You can use this function when customizing a reset password or enroll account email sending.                    //\n    * @locus Server                                                                                                   //\n    * @param {Object} email Which address of the user's to send the email to.                                         //\n    * @param {Object} user The user object to generate options for.                                                   //\n    * @param {String} url URL to which user is directed to confirm the email.                                         //\n    * @param {String} reason `resetPassword` or `enrollAccount`.                                                      //\n    * @returns {Object} Options which can be passed to `Email.send`.                                                  //\n    * @importFromPackage accounts-base                                                                                //\n    */                                                                                                                //\n                                                                                                                      //\nAccounts.generateOptionsForEmail = function (email, user, url, reason) {                                              // 674\n  var options = {                                                                                                     // 675\n    to: email,                                                                                                        // 676\n    from: Accounts.emailTemplates[reason].from ? Accounts.emailTemplates[reason].from(user) : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)                                                            // 680\n  };                                                                                                                  // 675\n                                                                                                                      //\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {                                                   // 683\n    options.text = Accounts.emailTemplates[reason].text(user, url);                                                   // 684\n  }                                                                                                                   // 685\n                                                                                                                      //\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {                                                   // 687\n    options.html = Accounts.emailTemplates[reason].html(user, url);                                                   // 688\n  }                                                                                                                   // 689\n                                                                                                                      //\n  if ((0, _typeof3.default)(Accounts.emailTemplates.headers) === 'object') {                                          // 691\n    options.headers = Accounts.emailTemplates.headers;                                                                // 692\n  }                                                                                                                   // 693\n                                                                                                                      //\n  return options;                                                                                                     // 695\n}; // send the user an email with a link that when opened allows the user                                             // 696\n// to set a new password, without the old password.                                                                   // 699\n/**                                                                                                                   // 701\n * @summary Send an email with a link the user can use to reset their password.                                       //\n * @locus Server                                                                                                      //\n * @param {String} userId The id of the user to send email to.                                                        //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.                       //\n * @returns {Object} Object with {email, user, token, url, options} values.                                           //\n * @importFromPackage accounts-base                                                                                   //\n */                                                                                                                   //\n                                                                                                                      //\nAccounts.sendResetPasswordEmail = function (userId, email, extraTokenData) {                                          // 710\n  var _Accounts$generateRes = Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData),            // 710\n      realEmail = _Accounts$generateRes.email,                                                                        // 710\n      user = _Accounts$generateRes.user,                                                                              // 710\n      token = _Accounts$generateRes.token;                                                                            // 710\n                                                                                                                      //\n  var url = Accounts.urls.resetPassword(token);                                                                       // 713\n  var options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');                              // 714\n  Email.send(options);                                                                                                // 715\n  return {                                                                                                            // 716\n    email: realEmail,                                                                                                 // 716\n    user: user,                                                                                                       // 716\n    token: token,                                                                                                     // 716\n    url: url,                                                                                                         // 716\n    options: options                                                                                                  // 716\n  };                                                                                                                  // 716\n}; // send the user an email informing them that their account was created, with                                      // 717\n// a link that when opened both marks their email as verified and forces them                                         // 720\n// to choose their password. The email must be one of the addresses in the                                            // 721\n// user's emails field, or undefined to pick the first email automatically.                                           // 722\n//                                                                                                                    // 723\n// This is not called automatically. It must be called manually if you                                                // 724\n// want to use enrollment emails.                                                                                     // 725\n/**                                                                                                                   // 727\n * @summary Send an email with a link the user can use to set their initial password.                                 //\n * @locus Server                                                                                                      //\n * @param {String} userId The id of the user to send email to.                                                        //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.                       //\n * @returns {Object} Object with {email, user, token, url, options} values.                                           //\n * @importFromPackage accounts-base                                                                                   //\n */                                                                                                                   //\n                                                                                                                      //\nAccounts.sendEnrollmentEmail = function (userId, email, extraTokenData) {                                             // 736\n  var _Accounts$generateRes2 = Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData),           // 736\n      realEmail = _Accounts$generateRes2.email,                                                                       // 736\n      user = _Accounts$generateRes2.user,                                                                             // 736\n      token = _Accounts$generateRes2.token;                                                                           // 736\n                                                                                                                      //\n  var url = Accounts.urls.enrollAccount(token);                                                                       // 739\n  var options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');                              // 740\n  Email.send(options);                                                                                                // 741\n  return {                                                                                                            // 742\n    email: realEmail,                                                                                                 // 742\n    user: user,                                                                                                       // 742\n    token: token,                                                                                                     // 742\n    url: url,                                                                                                         // 742\n    options: options                                                                                                  // 742\n  };                                                                                                                  // 742\n}; // Take token from sendResetPasswordEmail or sendEnrollmentEmail, change                                           // 743\n// the users password, and log them in.                                                                               // 747\n                                                                                                                      //\n                                                                                                                      //\nMeteor.methods({                                                                                                      // 748\n  resetPassword: function (token, newPassword) {                                                                      // 748\n    var self = this;                                                                                                  // 749\n    return Accounts._loginMethod(self, \"resetPassword\", arguments, \"password\", function () {                          // 750\n      check(token, String);                                                                                           // 756\n      check(newPassword, passwordValidator);                                                                          // 757\n      var user = Meteor.users.findOne({                                                                               // 759\n        \"services.password.reset.token\": token                                                                        // 760\n      });                                                                                                             // 759\n                                                                                                                      //\n      if (!user) {                                                                                                    // 761\n        throw new Meteor.Error(403, \"Token expired\");                                                                 // 762\n      }                                                                                                               // 763\n                                                                                                                      //\n      var when = user.services.password.reset.when;                                                                   // 764\n      var reason = user.services.password.reset.reason;                                                               // 765\n                                                                                                                      //\n      var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();                                              // 766\n                                                                                                                      //\n      if (reason === \"enroll\") {                                                                                      // 767\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();                                               // 768\n      }                                                                                                               // 769\n                                                                                                                      //\n      var currentTimeMs = Date.now();                                                                                 // 770\n      if (currentTimeMs - when > tokenLifetimeMs) throw new Meteor.Error(403, \"Token expired\");                       // 771\n      var email = user.services.password.reset.email;                                                                 // 773\n      if (!_.include(_.pluck(user.emails || [], 'address'), email)) return {                                          // 774\n        userId: user._id,                                                                                             // 776\n        error: new Meteor.Error(403, \"Token has invalid email address\")                                               // 777\n      };                                                                                                              // 775\n      var hashed = hashPassword(newPassword); // NOTE: We're about to invalidate tokens on the user, who we might be  // 780\n      // logged in as. Make sure to avoid logging ourselves out if this                                               // 783\n      // happens. But also make sure not to leave the connection in a state                                           // 784\n      // of having a bad token set if things fail.                                                                    // 785\n                                                                                                                      //\n      var oldToken = Accounts._getLoginToken(self.connection.id);                                                     // 786\n                                                                                                                      //\n      Accounts._setLoginToken(user._id, self.connection, null);                                                       // 787\n                                                                                                                      //\n      var resetToOldToken = function () {                                                                             // 788\n        Accounts._setLoginToken(user._id, self.connection, oldToken);                                                 // 789\n      };                                                                                                              // 790\n                                                                                                                      //\n      try {                                                                                                           // 792\n        // Update the user record by:                                                                                 // 793\n        // - Changing the password to the new one                                                                     // 794\n        // - Forgetting about the reset token that was just used                                                      // 795\n        // - Verifying their email, since they got the password reset via email.                                      // 796\n        var affectedRecords = Meteor.users.update({                                                                   // 797\n          _id: user._id,                                                                                              // 799\n          'emails.address': email,                                                                                    // 800\n          'services.password.reset.token': token                                                                      // 801\n        }, {                                                                                                          // 798\n          $set: {                                                                                                     // 803\n            'services.password.bcrypt': hashed,                                                                       // 803\n            'emails.$.verified': true                                                                                 // 804\n          },                                                                                                          // 803\n          $unset: {                                                                                                   // 805\n            'services.password.reset': 1,                                                                             // 805\n            'services.password.srp': 1                                                                                // 806\n          }                                                                                                           // 805\n        });                                                                                                           // 803\n        if (affectedRecords !== 1) return {                                                                           // 807\n          userId: user._id,                                                                                           // 809\n          error: new Meteor.Error(403, \"Invalid email\")                                                               // 810\n        };                                                                                                            // 808\n      } catch (err) {                                                                                                 // 812\n        resetToOldToken();                                                                                            // 813\n        throw err;                                                                                                    // 814\n      } // Replace all valid login tokens with new ones (changing                                                     // 815\n      // password should invalidate existing sessions).                                                               // 818\n                                                                                                                      //\n                                                                                                                      //\n      Accounts._clearAllLoginTokens(user._id);                                                                        // 819\n                                                                                                                      //\n      return {                                                                                                        // 821\n        userId: user._id                                                                                              // 821\n      };                                                                                                              // 821\n    });                                                                                                               // 822\n  }                                                                                                                   // 824\n}); ///                                                                                                               // 748\n/// EMAIL VERIFICATION                                                                                                // 827\n///                                                                                                                   // 828\n// send the user an email with a link that when opened marks that                                                     // 831\n// address as verified                                                                                                // 832\n/**                                                                                                                   // 834\n * @summary Send an email with a link the user can use verify their email address.                                    //\n * @locus Server                                                                                                      //\n * @param {String} userId The id of the user to send email to.                                                        //\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.                       //\n * @returns {Object} Object with {email, user, token, url, options} values.                                           //\n * @importFromPackage accounts-base                                                                                   //\n */                                                                                                                   //\n                                                                                                                      //\nAccounts.sendVerificationEmail = function (userId, email, extraTokenData) {                                           // 843\n  // XXX Also generate a link using which someone can delete this                                                     // 844\n  // account if they own said address but weren't those who created                                                   // 845\n  // this account.                                                                                                    // 846\n  var _Accounts$generateVer = Accounts.generateVerificationToken(userId, email, extraTokenData),                      // 843\n      realEmail = _Accounts$generateVer.email,                                                                        // 843\n      user = _Accounts$generateVer.user,                                                                              // 843\n      token = _Accounts$generateVer.token;                                                                            // 843\n                                                                                                                      //\n  var url = Accounts.urls.verifyEmail(token);                                                                         // 850\n  var options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');                                // 851\n  Email.send(options);                                                                                                // 852\n  return {                                                                                                            // 853\n    email: realEmail,                                                                                                 // 853\n    user: user,                                                                                                       // 853\n    token: token,                                                                                                     // 853\n    url: url,                                                                                                         // 853\n    options: options                                                                                                  // 853\n  };                                                                                                                  // 853\n}; // Take token from sendVerificationEmail, mark the email as verified,                                              // 854\n// and log them in.                                                                                                   // 857\n                                                                                                                      //\n                                                                                                                      //\nMeteor.methods({                                                                                                      // 858\n  verifyEmail: function (token) {                                                                                     // 858\n    var self = this;                                                                                                  // 859\n    return Accounts._loginMethod(self, \"verifyEmail\", arguments, \"password\", function () {                            // 860\n      check(token, String);                                                                                           // 866\n      var user = Meteor.users.findOne({                                                                               // 868\n        'services.email.verificationTokens.token': token                                                              // 869\n      });                                                                                                             // 869\n      if (!user) throw new Meteor.Error(403, \"Verify email link expired\");                                            // 870\n                                                                                                                      //\n      var tokenRecord = _.find(user.services.email.verificationTokens, function (t) {                                 // 873\n        return t.token == token;                                                                                      // 875\n      });                                                                                                             // 876\n                                                                                                                      //\n      if (!tokenRecord) return {                                                                                      // 877\n        userId: user._id,                                                                                             // 879\n        error: new Meteor.Error(403, \"Verify email link expired\")                                                     // 880\n      };                                                                                                              // 878\n                                                                                                                      //\n      var emailsRecord = _.find(user.emails, function (e) {                                                           // 883\n        return e.address == tokenRecord.address;                                                                      // 884\n      });                                                                                                             // 885\n                                                                                                                      //\n      if (!emailsRecord) return {                                                                                     // 886\n        userId: user._id,                                                                                             // 888\n        error: new Meteor.Error(403, \"Verify email link is for unknown address\")                                      // 889\n      }; // By including the address in the query, we can use 'emails.$' in the                                       // 887\n      // modifier to get a reference to the specific object in the emails                                             // 893\n      // array. See                                                                                                   // 894\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)                             // 895\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull                                                // 896\n                                                                                                                      //\n      Meteor.users.update({                                                                                           // 897\n        _id: user._id,                                                                                                // 898\n        'emails.address': tokenRecord.address                                                                         // 899\n      }, {                                                                                                            // 898\n        $set: {                                                                                                       // 900\n          'emails.$.verified': true                                                                                   // 900\n        },                                                                                                            // 900\n        $pull: {                                                                                                      // 901\n          'services.email.verificationTokens': {                                                                      // 901\n            address: tokenRecord.address                                                                              // 901\n          }                                                                                                           // 901\n        }                                                                                                             // 901\n      });                                                                                                             // 900\n      return {                                                                                                        // 903\n        userId: user._id                                                                                              // 903\n      };                                                                                                              // 903\n    });                                                                                                               // 904\n  }                                                                                                                   // 906\n}); /**                                                                                                               // 858\n     * @summary Add an email address for a user. Use this instead of directly                                         //\n     * updating the database. The operation will fail if there is a different user                                    //\n     * with an email only differing in case. If the specified user has an existing                                    //\n     * email only differing in case however, we replace it.                                                           //\n     * @locus Server                                                                                                  //\n     * @param {String} userId The ID of the user to update.                                                           //\n     * @param {String} newEmail A new email address for the user.                                                     //\n     * @param {Boolean} [verified] Optional - whether the new email address should                                    //\n     * be marked as verified. Defaults to false.                                                                      //\n     * @importFromPackage accounts-base                                                                               //\n     */                                                                                                               //\n                                                                                                                      //\nAccounts.addEmail = function (userId, newEmail, verified) {                                                           // 920\n  check(userId, NonEmptyString);                                                                                      // 921\n  check(newEmail, NonEmptyString);                                                                                    // 922\n  check(verified, Match.Optional(Boolean));                                                                           // 923\n                                                                                                                      //\n  if (_.isUndefined(verified)) {                                                                                      // 925\n    verified = false;                                                                                                 // 926\n  }                                                                                                                   // 927\n                                                                                                                      //\n  var user = Meteor.users.findOne(userId);                                                                            // 929\n  if (!user) throw new Meteor.Error(403, \"User not found\"); // Allow users to change their own email to a version with a different case\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case                                             // 935\n  // insensitive check across all emails in the database here because: (1) if                                         // 936\n  // there is no case-insensitive duplicate between this user and other users,                                        // 937\n  // then we are OK and (2) if this would create a conflict with other users                                          // 938\n  // then there would already be a case-insensitive duplicate and we can't fix                                        // 939\n  // that in this code anyway.                                                                                        // 940\n                                                                                                                      //\n  var caseInsensitiveRegExp = new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');                            // 941\n                                                                                                                      //\n  var didUpdateOwnEmail = _.any(user.emails, function (email, index) {                                                // 944\n    if (caseInsensitiveRegExp.test(email.address)) {                                                                  // 945\n      Meteor.users.update({                                                                                           // 946\n        _id: user._id,                                                                                                // 947\n        'emails.address': email.address                                                                               // 948\n      }, {                                                                                                            // 946\n        $set: {                                                                                                       // 949\n          'emails.$.address': newEmail,                                                                               // 950\n          'emails.$.verified': verified                                                                               // 951\n        }                                                                                                             // 949\n      });                                                                                                             // 949\n      return true;                                                                                                    // 953\n    }                                                                                                                 // 954\n                                                                                                                      //\n    return false;                                                                                                     // 956\n  }); // In the other updates below, we have to do another call to                                                    // 957\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values                                        // 960\n  // were added to the database in the meantime. We don't have to do this for                                         // 961\n  // the case where the user is updating their email address to one that is the                                       // 962\n  // same as before, but only different because of capitalization. Read the                                           // 963\n  // big comment above to understand why.                                                                             // 964\n                                                                                                                      //\n                                                                                                                      //\n  if (didUpdateOwnEmail) {                                                                                            // 966\n    return;                                                                                                           // 967\n  } // Perform a case insensitive check for duplicates before update                                                  // 968\n                                                                                                                      //\n                                                                                                                      //\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                   // 971\n  Meteor.users.update({                                                                                               // 973\n    _id: user._id                                                                                                     // 974\n  }, {                                                                                                                // 973\n    $addToSet: {                                                                                                      // 976\n      emails: {                                                                                                       // 977\n        address: newEmail,                                                                                            // 978\n        verified: verified                                                                                            // 979\n      }                                                                                                               // 977\n    }                                                                                                                 // 976\n  }); // Perform another check after update, in case a matching user has been                                         // 975\n  // inserted in the meantime                                                                                         // 985\n                                                                                                                      //\n  try {                                                                                                               // 986\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);                                 // 987\n  } catch (ex) {                                                                                                      // 988\n    // Undo update if the check fails                                                                                 // 989\n    Meteor.users.update({                                                                                             // 990\n      _id: user._id                                                                                                   // 990\n    }, {                                                                                                              // 990\n      $pull: {                                                                                                        // 991\n        emails: {                                                                                                     // 991\n          address: newEmail                                                                                           // 991\n        }                                                                                                             // 991\n      }                                                                                                               // 991\n    });                                                                                                               // 991\n    throw ex;                                                                                                         // 992\n  }                                                                                                                   // 993\n}; /**                                                                                                                // 994\n    * @summary Remove an email address for a user. Use this instead of updating                                       //\n    * the database directly.                                                                                          //\n    * @locus Server                                                                                                   //\n    * @param {String} userId The ID of the user to update.                                                            //\n    * @param {String} email The email address to remove.                                                              //\n    * @importFromPackage accounts-base                                                                                //\n    */                                                                                                                //\n                                                                                                                      //\nAccounts.removeEmail = function (userId, email) {                                                                     // 1004\n  check(userId, NonEmptyString);                                                                                      // 1005\n  check(email, NonEmptyString);                                                                                       // 1006\n  var user = Meteor.users.findOne(userId);                                                                            // 1008\n  if (!user) throw new Meteor.Error(403, \"User not found\");                                                           // 1009\n  Meteor.users.update({                                                                                               // 1012\n    _id: user._id                                                                                                     // 1012\n  }, {                                                                                                                // 1012\n    $pull: {                                                                                                          // 1013\n      emails: {                                                                                                       // 1013\n        address: email                                                                                                // 1013\n      }                                                                                                               // 1013\n    }                                                                                                                 // 1013\n  });                                                                                                                 // 1013\n}; ///                                                                                                                // 1014\n/// CREATING USERS                                                                                                    // 1017\n///                                                                                                                   // 1018\n// Shared createUser function called from the createUser method, both                                                 // 1020\n// if originates in client or server code. Calls user provided hooks,                                                 // 1021\n// does the actual user insertion.                                                                                    // 1022\n//                                                                                                                    // 1023\n// returns the user id                                                                                                // 1024\n                                                                                                                      //\n                                                                                                                      //\nvar createUser = function (options) {                                                                                 // 1025\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary                                              // 1026\n  // options.                                                                                                         // 1027\n  check(options, Match.ObjectIncluding({                                                                              // 1028\n    username: Match.Optional(String),                                                                                 // 1029\n    email: Match.Optional(String),                                                                                    // 1030\n    password: Match.Optional(passwordValidator)                                                                       // 1031\n  }));                                                                                                                // 1028\n  var username = options.username;                                                                                    // 1034\n  var email = options.email;                                                                                          // 1035\n  if (!username && !email) throw new Meteor.Error(400, \"Need to set a username or email\");                            // 1036\n  var user = {                                                                                                        // 1039\n    services: {}                                                                                                      // 1039\n  };                                                                                                                  // 1039\n                                                                                                                      //\n  if (options.password) {                                                                                             // 1040\n    var hashed = hashPassword(options.password);                                                                      // 1041\n    user.services.password = {                                                                                        // 1042\n      bcrypt: hashed                                                                                                  // 1042\n    };                                                                                                                // 1042\n  }                                                                                                                   // 1043\n                                                                                                                      //\n  if (username) user.username = username;                                                                             // 1045\n  if (email) user.emails = [{                                                                                         // 1047\n    address: email,                                                                                                   // 1048\n    verified: false                                                                                                   // 1048\n  }]; // Perform a case insensitive check before insert                                                               // 1048\n                                                                                                                      //\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);                                                // 1051\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);                                                // 1052\n  var userId = Accounts.insertUserDoc(options, user); // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime                                                                                         // 1056\n                                                                                                                      //\n  try {                                                                                                               // 1057\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);                                      // 1058\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);                                      // 1059\n  } catch (ex) {                                                                                                      // 1060\n    // Remove inserted user if the check fails                                                                        // 1061\n    Meteor.users.remove(userId);                                                                                      // 1062\n    throw ex;                                                                                                         // 1063\n  }                                                                                                                   // 1064\n                                                                                                                      //\n  return userId;                                                                                                      // 1065\n}; // method for create user. Requests come from the client.                                                          // 1066\n                                                                                                                      //\n                                                                                                                      //\nMeteor.methods({                                                                                                      // 1069\n  createUser: function (options) {                                                                                    // 1069\n    var self = this;                                                                                                  // 1070\n    return Accounts._loginMethod(self, \"createUser\", arguments, \"password\", function () {                             // 1071\n      // createUser() above does more checking.                                                                       // 1077\n      check(options, Object);                                                                                         // 1078\n      if (Accounts._options.forbidClientAccountCreation) return {                                                     // 1079\n        error: new Meteor.Error(403, \"Signups forbidden\")                                                             // 1081\n      }; // Create user. result contains id and token.                                                                // 1080\n                                                                                                                      //\n      var userId = createUser(options); // safety belt. createUser is supposed to throw on error. send 500 error      // 1085\n      // instead of sending a verification email with empty userid.                                                   // 1087\n                                                                                                                      //\n      if (!userId) throw new Error(\"createUser failed to insert new user\"); // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to                                                   // 1092\n      // that address.                                                                                                // 1093\n                                                                                                                      //\n      if (options.email && Accounts._options.sendVerificationEmail) Accounts.sendVerificationEmail(userId, options.email); // client gets logged in as the new user afterwards.\n                                                                                                                      //\n      return {                                                                                                        // 1098\n        userId: userId                                                                                                // 1098\n      };                                                                                                              // 1098\n    });                                                                                                               // 1099\n  }                                                                                                                   // 1101\n}); // Create user directly on the server.                                                                            // 1069\n//                                                                                                                    // 1104\n// Unlike the client version, this does not log you in as this user                                                   // 1105\n// after creation.                                                                                                    // 1106\n//                                                                                                                    // 1107\n// returns userId or throws an error if it can't create                                                               // 1108\n//                                                                                                                    // 1109\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,                                        // 1110\n// which is always empty when called from the createUser method? eg, \"admin:                                          // 1111\n// true\", which we want to prevent the client from setting, but which a custom                                        // 1112\n// method calling Accounts.createUser could set?                                                                      // 1113\n//                                                                                                                    // 1114\n                                                                                                                      //\nAccounts.createUser = function (options, callback) {                                                                  // 1115\n  options = _.clone(options); // XXX allow an optional callback?                                                      // 1116\n                                                                                                                      //\n  if (callback) {                                                                                                     // 1119\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");                            // 1120\n  }                                                                                                                   // 1121\n                                                                                                                      //\n  return createUser(options);                                                                                         // 1123\n}; ///                                                                                                                // 1124\n/// PASSWORD-SPECIFIC INDEXES ON USERS                                                                                // 1127\n///                                                                                                                   // 1128\n                                                                                                                      //\n                                                                                                                      //\nMeteor.users._ensureIndex('services.email.verificationTokens.token', {                                                // 1129\n  unique: 1,                                                                                                          // 1130\n  sparse: 1                                                                                                           // 1130\n});                                                                                                                   // 1130\n                                                                                                                      //\nMeteor.users._ensureIndex('services.password.reset.token', {                                                          // 1131\n  unique: 1,                                                                                                          // 1132\n  sparse: 1                                                                                                           // 1132\n});                                                                                                                   // 1132\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}},{\n  \"extensions\": [\n    \".js\",\n    \".json\"\n  ]\n});\nrequire(\"./node_modules/meteor/accounts-password/email_templates.js\");\nrequire(\"./node_modules/meteor/accounts-password/password_server.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\nPackage['accounts-password'] = {};\n\n})();\n","servePath":"/packages/accounts-password.js","sourceMap":{"version":3,"sources":["packages/accounts-password/email_templates.js","packages/accounts-password/password_server.js"],"names":["greet","welcomeMsg","user","url","greeting","profile","name","Accounts","emailTemplates","from","siteName","Meteor","absoluteUrl","replace","resetPassword","subject","text","verifyEmail","enrollAccount","bcrypt","NpmModuleBcrypt","bcryptHash","wrapAsync","hash","bcryptCompare","compare","_bcryptRounds","getPasswordString","password","SHA256","algorithm","Error","digest","hashPassword","_checkPassword","result","userId","_id","services","error","handleError","checkPassword","msg","throwError","_options","ambiguousErrorMessages","_findUserByQuery","query","id","users","findOne","fieldName","fieldValue","username","email","selector","selectorForFastCaseInsensitiveLookup","candidateUsers","find","fetch","length","findUserByUsername","findUserByEmail","string","prefix","substring","Math","min","orClause","_","map","generateCasePermutationsForString","prefixPermutation","RegExp","_escapeRegExp","caseInsensitiveClause","$and","$or","permutations","i","ch","charAt","flatten","lowerCaseChar","toLowerCase","upperCaseChar","toUpperCase","checkForCaseInsensitiveDuplicates","displayName","ownUserId","skipCheck","has","_skipCaseInsensitiveChecksForTest","matchedUsers","NonEmptyString","Match","Where","x","check","String","userQueryValidator","Optional","keys","passwordValidator","OneOf","registerLoginHandler","options","srp","undefined","verifier","newVerifier","SRP","generateVerifier","identity","salt","EJSON","stringify","format","v1","v2","hashedIdentityAndPassword","salted","update","$unset","$set","setUsername","newUsername","oldUsername","ex","methods","changePassword","oldPassword","newPassword","hashed","currentToken","_getLoginToken","connection","$pull","hashedToken","$ne","passwordChanged","setPassword","newPlaintextPassword","extend","logout","forgotPassword","emails","pluck","caseSensitiveEmail","sendResetPasswordEmail","generateResetToken","reason","extraTokenData","address","contains","token","Random","secret","tokenRecord","when","Date","_ensure","reset","generateVerificationToken","emailRecord","e","verified","$push","verificationTokens","push","generateOptionsForEmail","to","html","headers","realEmail","urls","Email","send","sendEnrollmentEmail","self","_loginMethod","arguments","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","_getPasswordEnrollTokenLifetimeMs","currentTimeMs","now","include","oldToken","_setLoginToken","resetToOldToken","affectedRecords","err","_clearAllLoginTokens","sendVerificationEmail","t","emailsRecord","addEmail","newEmail","Boolean","isUndefined","caseInsensitiveRegExp","didUpdateOwnEmail","any","index","test","$addToSet","removeEmail","createUser","ObjectIncluding","insertUserDoc","remove","Object","forbidClientAccountCreation","callback","clone","_ensureIndex","unique","sparse"],"mappings":"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","file":"/packages/accounts-password.js","sourcesContent":["function greet(welcomeMsg) {\n  return function(user, url) {\n      var greeting = (user.profile && user.profile.name) ?\n            (\"Hello \" + user.profile.name + \",\") : \"Hello,\";\n      return `${greeting}\n\n${welcomeMsg}, simply click the link below.\n\n${url}\n\nThanks.\n`;\n  };\n}\n\n/**\n * @summary Options to customize emails sent from the Accounts system.\n * @locus Server\n * @importFromPackage accounts-base\n */\nAccounts.emailTemplates = {\n  from: \"Accounts Example <no-reply@example.com>\",\n  siteName: Meteor.absoluteUrl().replace(/^https?:\\/\\//, '').replace(/\\/$/, ''),\n\n  resetPassword: {\n    subject: function(user) {\n      return \"How to reset your password on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To reset your password\")\n  },\n  verifyEmail: {\n    subject: function(user) {\n      return \"How to verify email address on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To verify your account email\")\n  },\n  enrollAccount: {\n    subject: function(user) {\n      return \"An account has been created for you on \" + Accounts.emailTemplates.siteName;\n    },\n    text: greet(\"To start using the service\")\n  }\n};\n","/// BCRYPT\n\nvar bcrypt = NpmModuleBcrypt;\nvar bcryptHash = Meteor.wrapAsync(bcrypt.hash);\nvar bcryptCompare = Meteor.wrapAsync(bcrypt.compare);\n\n// User records have a 'services.password.bcrypt' field on them to hold\n// their hashed passwords (unless they have a 'services.password.srp'\n// field, in which case they will be upgraded to bcrypt the next time\n// they log in).\n//\n// When the client sends a password to the server, it can either be a\n// string (the plaintext password) or an object with keys 'digest' and\n// 'algorithm' (must be \"sha-256\" for now). The Meteor client always sends\n// password objects { digest: *, algorithm: \"sha-256\" }, but DDP clients\n// that don't have access to SHA can just send plaintext passwords as\n// strings.\n//\n// When the server receives a plaintext password as a string, it always\n// hashes it with SHA256 before passing it into bcrypt. When the server\n// receives a password as an object, it asserts that the algorithm is\n// \"sha-256\" and then passes the digest to bcrypt.\n\n\nAccounts._bcryptRounds = 10;\n\n// Given a 'password' from the client, extract the string that we should\n// bcrypt. 'password' can be one of:\n//  - String (the plaintext password)\n//  - Object with 'digest' and 'algorithm' keys. 'algorithm' must be \"sha-256\".\n//\nvar getPasswordString = function (password) {\n  if (typeof password === \"string\") {\n    password = SHA256(password);\n  } else { // 'password' is an object\n    if (password.algorithm !== \"sha-256\") {\n      throw new Error(\"Invalid password hash algorithm. \" +\n                      \"Only 'sha-256' is allowed.\");\n    }\n    password = password.digest;\n  }\n  return password;\n};\n\n// Use bcrypt to hash the password for storage in the database.\n// `password` can be a string (in which case it will be run through\n// SHA256 before bcrypt) or an object with properties `digest` and\n// `algorithm` (in which case we bcrypt `password.digest`).\n//\nvar hashPassword = function (password) {\n  password = getPasswordString(password);\n  return bcryptHash(password, Accounts._bcryptRounds);\n};\n\n// Check whether the provided password matches the bcrypt'ed password in\n// the database user record. `password` can be a string (in which case\n// it will be run through SHA256 before bcrypt) or an object with\n// properties `digest` and `algorithm` (in which case we bcrypt\n// `password.digest`).\n//\nAccounts._checkPassword = function (user, password) {\n  var result = {\n    userId: user._id\n  };\n\n  password = getPasswordString(password);\n\n  if (! bcryptCompare(password, user.services.password.bcrypt)) {\n    result.error = handleError(\"Incorrect password\", false);\n  }\n\n  return result;\n};\nvar checkPassword = Accounts._checkPassword;\n\n///\n/// ERROR HANDLER\n///\nconst handleError = (msg, throwError = true) => {\n  const error = new Meteor.Error(\n    403, \n    Accounts._options.ambiguousErrorMessages\n      ? \"Something went wrong. Please check your credentials.\"\n      : msg\n  );\n  if (throwError) {\n    throw error;\n  }\n  return error;\n};\n\n///\n/// LOGIN\n///\n\nAccounts._findUserByQuery = function (query) {\n  var user = null;\n\n  if (query.id) {\n    user = Meteor.users.findOne({ _id: query.id });\n  } else {\n    var fieldName;\n    var fieldValue;\n    if (query.username) {\n      fieldName = 'username';\n      fieldValue = query.username;\n    } else if (query.email) {\n      fieldName = 'emails.address';\n      fieldValue = query.email;\n    } else {\n      throw new Error(\"shouldn't happen (validation missed something)\");\n    }\n    var selector = {};\n    selector[fieldName] = fieldValue;\n    user = Meteor.users.findOne(selector);\n    // If user is not found, try a case insensitive lookup\n    if (!user) {\n      selector = selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n      var candidateUsers = Meteor.users.find(selector).fetch();\n      // No match if multiple candidates are found\n      if (candidateUsers.length === 1) {\n        user = candidateUsers[0];\n      }\n    }\n  }\n\n  return user;\n};\n\n/**\n * @summary Finds the user with the specified username.\n * First tries to match username case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} username The username to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByUsername = function (username) {\n  return Accounts._findUserByQuery({\n    username: username\n  });\n};\n\n/**\n * @summary Finds the user with the specified email.\n * First tries to match email case sensitively; if that fails, it\n * tries case insensitively; but if more than one user matches the case\n * insensitive search, it returns null.\n * @locus Server\n * @param {String} email The email address to look for\n * @returns {Object} A user if found, else null\n * @importFromPackage accounts-base\n */\nAccounts.findUserByEmail = function (email) {\n  return Accounts._findUserByQuery({\n    email: email\n  });\n};\n\n// Generates a MongoDB selector that can be used to perform a fast case\n// insensitive lookup for the given fieldName and string. Since MongoDB does\n// not support case insensitive indexes, and case insensitive regex queries\n// are slow, we construct a set of prefix selectors for all permutations of\n// the first 4 characters ourselves. We first attempt to matching against\n// these, and because 'prefix expression' regex queries do use indexes (see\n// http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n// this has been found to greatly improve performance (from 1200ms to 5ms in a\n// test with 1.000.000 users).\nvar selectorForFastCaseInsensitiveLookup = function (fieldName, string) {\n  // Performance seems to improve up to 4 prefix characters\n  var prefix = string.substring(0, Math.min(string.length, 4));\n  var orClause = _.map(generateCasePermutationsForString(prefix),\n    function (prefixPermutation) {\n      var selector = {};\n      selector[fieldName] =\n        new RegExp('^' + Meteor._escapeRegExp(prefixPermutation));\n      return selector;\n    });\n  var caseInsensitiveClause = {};\n  caseInsensitiveClause[fieldName] =\n    new RegExp('^' + Meteor._escapeRegExp(string) + '$', 'i')\n  return {$and: [{$or: orClause}, caseInsensitiveClause]};\n}\n\n// Generates permutations of all case variations of a given string.\nvar generateCasePermutationsForString = function (string) {\n  var permutations = [''];\n  for (var i = 0; i < string.length; i++) {\n    var ch = string.charAt(i);\n    permutations = _.flatten(_.map(permutations, function (prefix) {\n      var lowerCaseChar = ch.toLowerCase();\n      var upperCaseChar = ch.toUpperCase();\n      // Don't add unneccesary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n  return permutations;\n}\n\nvar checkForCaseInsensitiveDuplicates = function (fieldName, displayName, fieldValue, ownUserId) {\n  // Some tests need the ability to add users with the same case insensitive\n  // value, hence the _skipCaseInsensitiveChecksForTest check\n  var skipCheck = _.has(Accounts._skipCaseInsensitiveChecksForTest, fieldValue);\n\n  if (fieldValue && !skipCheck) {\n    var matchedUsers = Meteor.users.find(\n      selectorForFastCaseInsensitiveLookup(fieldName, fieldValue)).fetch();\n\n    if (matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n        // Otherwise, check to see if there are multiple matches or a match\n        // that is not us\n        (matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId))) {\n      handleError(displayName + \" already exists.\");\n    }\n  }\n};\n\n// XXX maybe this belongs in the check package\nvar NonEmptyString = Match.Where(function (x) {\n  check(x, String);\n  return x.length > 0;\n});\n\nvar userQueryValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(NonEmptyString),\n    username: Match.Optional(NonEmptyString),\n    email: Match.Optional(NonEmptyString)\n  });\n  if (_.keys(user).length !== 1)\n    throw new Match.Error(\"User property must have exactly one field\");\n  return true;\n});\n\nvar passwordValidator = Match.OneOf(\n  String,\n  { digest: String, algorithm: String }\n);\n\n// Handler to login with a password.\n//\n// The Meteor client sets options.password to an object with keys\n// 'digest' (set to SHA256(password)) and 'algorithm' (\"sha-256\").\n//\n// For other DDP clients which don't have access to SHA, the handler\n// also accepts the plaintext password in options.password as a string.\n//\n// (It might be nice if servers could turn the plaintext password\n// option off. Or maybe it should be opt-in, not opt-out?\n// Accounts.config option?)\n//\n// Note that neither password option is secure without SSL.\n//\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (! options.password || options.srp)\n    return undefined; // don't handle\n\n  check(options, {\n    user: userQueryValidator,\n    password: passwordValidator\n  });\n\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      !(user.services.password.bcrypt || user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (!user.services.password.bcrypt) {\n    if (typeof options.password === \"string\") {\n      // The client has presented a plaintext password, and the user is\n      // not upgraded to bcrypt yet. We don't attempt to tell the client\n      // to upgrade to bcrypt, because it might be a standalone DDP\n      // client doesn't know how to do such a thing.\n      var verifier = user.services.password.srp;\n      var newVerifier = SRP.generateVerifier(options.password, {\n        identity: verifier.identity, salt: verifier.salt});\n\n      if (verifier.verifier !== newVerifier.verifier) {\n        return {\n          userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n          error: handleError(\"Incorrect password\", false)\n        };\n      }\n\n      return {userId: user._id};\n    } else {\n      // Tell the client to use the SRP upgrade process.\n      throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n        format: 'srp',\n        identity: user.services.password.srp.identity\n      }));\n    }\n  }\n\n  return checkPassword(\n    user,\n    options.password\n  );\n});\n\n// Handler to login using the SRP upgrade path. To use this login\n// handler, the client must provide:\n//   - srp: H(identity + \":\" + password)\n//   - password: a string or an object with properties 'digest' and 'algorithm'\n//\n// We use `options.srp` to verify that the client knows the correct\n// password without doing a full SRP flow. Once we've checked that, we\n// upgrade the user to bcrypt and remove the SRP information from the\n// user document.\n//\n// The client ends up using this login handler after trying the normal\n// login handler (above), which throws an error telling the client to\n// try the SRP upgrade path.\n//\n// XXX COMPAT WITH 0.8.1.3\nAccounts.registerLoginHandler(\"password\", function (options) {\n  if (!options.srp || !options.password) {\n    return undefined; // don't handle\n  }\n\n  check(options, {\n    user: userQueryValidator,\n    srp: String,\n    password: passwordValidator\n  });\n\n  var user = Accounts._findUserByQuery(options.user);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  // Check to see if another simultaneous login has already upgraded\n  // the user record to bcrypt.\n  if (user.services && user.services.password && user.services.password.bcrypt) {\n    return checkPassword(user, options.password);\n  }\n\n  if (!(user.services && user.services.password && user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  var v1 = user.services.password.srp.verifier;\n  var v2 = SRP.generateVerifier(\n    null,\n    {\n      hashedIdentityAndPassword: options.srp,\n      salt: user.services.password.srp.salt\n    }\n  ).verifier;\n  if (v1 !== v2) {\n    return {\n      userId: Accounts._options.ambiguousErrorMessages ? null : user._id,\n      error: handleError(\"Incorrect password\", false)\n    };\n  }\n\n  // Upgrade to bcrypt on successful login.\n  var salted = hashPassword(options.password);\n  Meteor.users.update(\n    user._id,\n    {\n      $unset: { 'services.password.srp': 1 },\n      $set: { 'services.password.bcrypt': salted }\n    }\n  );\n\n  return {userId: user._id};\n});\n\n\n///\n/// CHANGING\n///\n\n/**\n * @summary Change a user's username. Use this instead of updating the\n * database directly. The operation will fail if there is an existing user\n * with a username only differing in case.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newUsername A new username for the user.\n * @importFromPackage accounts-base\n */\nAccounts.setUsername = function (userId, newUsername) {\n  check(userId, NonEmptyString);\n  check(newUsername, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  var oldUsername = user.username;\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n\n  Meteor.users.update({_id: user._id}, {$set: {username: newUsername}});\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', newUsername, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id}, {$set: {username: oldUsername}});\n    throw ex;\n  }\n};\n\n// Let the user change their own password if they know the old\n// password. `oldPassword` and `newPassword` should be objects with keys\n// `digest` and `algorithm` (representing the SHA256 of the password).\n//\n// XXX COMPAT WITH 0.8.1.3\n// Like the login method, if the user hasn't been upgraded from SRP to\n// bcrypt yet, then this method will throw an 'old password format'\n// error. The client should call the SRP upgrade login handler and then\n// retry this method again.\n//\n// UNLIKE the login method, there is no way to avoid getting SRP upgrade\n// errors thrown. The reasoning for this is that clients using this\n// method directly will need to be updated anyway because we no longer\n// support the SRP flow that they would have been doing to use this\n// method previously.\nMeteor.methods({changePassword: function (oldPassword, newPassword) {\n  check(oldPassword, passwordValidator);\n  check(newPassword, passwordValidator);\n\n  if (!this.userId) {\n    throw new Meteor.Error(401, \"Must be logged in\");\n  }\n\n  var user = Meteor.users.findOne(this.userId);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  if (!user.services || !user.services.password ||\n      (!user.services.password.bcrypt && !user.services.password.srp)) {\n    handleError(\"User has no password set\");\n  }\n\n  if (! user.services.password.bcrypt) {\n    throw new Meteor.Error(400, \"old password format\", EJSON.stringify({\n      format: 'srp',\n      identity: user.services.password.srp.identity\n    }));\n  }\n\n  var result = checkPassword(user, oldPassword);\n  if (result.error) {\n    throw result.error;\n  }\n\n  var hashed = hashPassword(newPassword);\n\n  // It would be better if this removed ALL existing tokens and replaced\n  // the token for the current connection with a new one, but that would\n  // be tricky, so we'll settle for just replacing all tokens other than\n  // the one for the current connection.\n  var currentToken = Accounts._getLoginToken(this.connection.id);\n  Meteor.users.update(\n    { _id: this.userId },\n    {\n      $set: { 'services.password.bcrypt': hashed },\n      $pull: {\n        'services.resume.loginTokens': { hashedToken: { $ne: currentToken } }\n      },\n      $unset: { 'services.password.reset': 1 }\n    }\n  );\n\n  return {passwordChanged: true};\n}});\n\n\n// Force change the users password.\n\n/**\n * @summary Forcibly change the password for a user.\n * @locus Server\n * @param {String} userId The id of the user to update.\n * @param {String} newPassword A new password for the user.\n * @param {Object} [options]\n * @param {Object} options.logout Logout all current connections with this userId (default: true)\n * @importFromPackage accounts-base\n */\nAccounts.setPassword = function (userId, newPlaintextPassword, options) {\n  options = _.extend({logout: true}, options);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    throw new Meteor.Error(403, \"User not found\");\n  }\n\n  var update = {\n    $unset: {\n      'services.password.srp': 1, // XXX COMPAT WITH 0.8.1.3\n      'services.password.reset': 1\n    },\n    $set: {'services.password.bcrypt': hashPassword(newPlaintextPassword)}\n  };\n\n  if (options.logout) {\n    update.$unset['services.resume.loginTokens'] = 1;\n  }\n\n  Meteor.users.update({_id: user._id}, update);\n};\n\n\n///\n/// RESETTING VIA EMAIL\n///\n\n// Method called by a user to request a password reset email. This is\n// the start of the reset process.\nMeteor.methods({forgotPassword: function (options) {\n  check(options, {email: String});\n\n  var user = Accounts.findUserByEmail(options.email);\n  if (!user) {\n    handleError(\"User not found\");\n  }\n\n  const emails = _.pluck(user.emails || [], 'address');\n  const caseSensitiveEmail = _.find(emails, email => {\n    return email.toLowerCase() === options.email.toLowerCase();\n  });\n\n  Accounts.sendResetPasswordEmail(user._id, caseSensitiveEmail);\n}});\n\n/**\n * @summary Generates a reset token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the reset token for.\n * @param {String} email Which address of the user to generate the reset token for. This address must be in the user's `emails` list. If `null`, defaults to the first email in the list.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateResetToken = function (userId, email, reason, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first email if we weren't passed an email.\n  if (!email && user.emails && user.emails[0]) {\n    email = user.emails[0].address;\n  }\n\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    email: email,\n    when: new Date()\n  };\n\n  if (reason === 'resetPassword') {\n    tokenRecord.reason = 'reset';\n  } else if (reason === 'enrollAccount') {\n    tokenRecord.reason = 'enroll';\n  } else if (reason) {\n    // fallback so that this function can be used for unknown reasons as well\n    tokenRecord.reason = reason;\n  }\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$set: {\n    'services.password.reset': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'password').reset = tokenRecord;\n\n  return {email, user, token};\n};\n\n/**\n * @summary Generates an e-mail verification token and saves it into the database.\n * @locus Server\n * @param {String} userId The id of the user to generate the  e-mail verification token for.\n * @param {String} email Which address of the user to generate the e-mail verification token for. This address must be in the user's `emails` list. If `null`, defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token} values.\n * @importFromPackage accounts-base\n */\nAccounts.generateVerificationToken = function (userId, email, extraTokenData) {\n  // Make sure the user exists, and email is one of their addresses.\n  var user = Meteor.users.findOne(userId);\n  if (!user) {\n    handleError(\"Can't find user\");\n  }\n\n  // pick the first unverified email if we weren't passed an email.\n  if (!email) {\n    var emailRecord = _.find(user.emails || [], function (e) { return !e.verified; });\n    email = (emailRecord || {}).address;\n\n    if (!email) {\n      handleError(\"That user has no unverified email addresses.\");\n    }\n  }\n\n  // make sure we have a valid email\n  if (!email || !_.contains(_.pluck(user.emails || [], 'address'), email)) {\n    handleError(\"No such email for user.\");\n  }\n\n  var token = Random.secret();\n  var tokenRecord = {\n    token: token,\n    // TODO: This should probably be renamed to \"email\" to match reset token record.\n    address: email,\n    when: new Date()\n  };\n\n  if (extraTokenData) {\n    _.extend(tokenRecord, extraTokenData);\n  }\n\n  Meteor.users.update({_id: user._id}, {$push: {\n    'services.email.verificationTokens': tokenRecord\n  }});\n\n  // before passing to template, update user object with new token\n  Meteor._ensure(user, 'services', 'email');\n  if (!user.services.email.verificationTokens) {\n    user.services.email.verificationTokens = [];\n  }\n  user.services.email.verificationTokens.push(tokenRecord);\n\n  return {email, user, token};\n};\n\n/**\n * @summary Creates options for email sending for reset password and enroll account emails.\n * You can use this function when customizing a reset password or enroll account email sending.\n * @locus Server\n * @param {Object} email Which address of the user's to send the email to.\n * @param {Object} user The user object to generate options for.\n * @param {String} url URL to which user is directed to confirm the email.\n * @param {String} reason `resetPassword` or `enrollAccount`.\n * @returns {Object} Options which can be passed to `Email.send`.\n * @importFromPackage accounts-base\n */\nAccounts.generateOptionsForEmail = function (email, user, url, reason) {\n  var options = {\n    to: email,\n    from: Accounts.emailTemplates[reason].from\n      ? Accounts.emailTemplates[reason].from(user)\n      : Accounts.emailTemplates.from,\n    subject: Accounts.emailTemplates[reason].subject(user)\n  };\n\n  if (typeof Accounts.emailTemplates[reason].text === 'function') {\n    options.text = Accounts.emailTemplates[reason].text(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates[reason].html === 'function') {\n    options.html = Accounts.emailTemplates[reason].html(user, url);\n  }\n\n  if (typeof Accounts.emailTemplates.headers === 'object') {\n    options.headers = Accounts.emailTemplates.headers;\n  }\n\n  return options;\n};\n\n// send the user an email with a link that when opened allows the user\n// to set a new password, without the old password.\n\n/**\n * @summary Send an email with a link the user can use to reset their password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendResetPasswordEmail = function (userId, email, extraTokenData) {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'resetPassword', extraTokenData);\n  const url = Accounts.urls.resetPassword(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'resetPassword');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n// send the user an email informing them that their account was created, with\n// a link that when opened both marks their email as verified and forces them\n// to choose their password. The email must be one of the addresses in the\n// user's emails field, or undefined to pick the first email automatically.\n//\n// This is not called automatically. It must be called manually if you\n// want to use enrollment emails.\n\n/**\n * @summary Send an email with a link the user can use to set their initial password.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendEnrollmentEmail = function (userId, email, extraTokenData) {\n  const {email: realEmail, user, token} =\n    Accounts.generateResetToken(userId, email, 'enrollAccount', extraTokenData);\n  const url = Accounts.urls.enrollAccount(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'enrollAccount');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n\n// Take token from sendResetPasswordEmail or sendEnrollmentEmail, change\n// the users password, and log them in.\nMeteor.methods({resetPassword: function (token, newPassword) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"resetPassword\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n      check(newPassword, passwordValidator);\n\n      var user = Meteor.users.findOne({\n        \"services.password.reset.token\": token});\n      if (!user) {\n        throw new Meteor.Error(403, \"Token expired\");\n      }\n      var when = user.services.password.reset.when;\n      var reason = user.services.password.reset.reason;\n      var tokenLifetimeMs = Accounts._getPasswordResetTokenLifetimeMs();\n      if (reason === \"enroll\") {\n        tokenLifetimeMs = Accounts._getPasswordEnrollTokenLifetimeMs();\n      }\n      var currentTimeMs = Date.now();\n      if ((currentTimeMs - when) > tokenLifetimeMs)\n        throw new Meteor.Error(403, \"Token expired\");\n      var email = user.services.password.reset.email;\n      if (!_.include(_.pluck(user.emails || [], 'address'), email))\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Token has invalid email address\")\n        };\n\n      var hashed = hashPassword(newPassword);\n\n      // NOTE: We're about to invalidate tokens on the user, who we might be\n      // logged in as. Make sure to avoid logging ourselves out if this\n      // happens. But also make sure not to leave the connection in a state\n      // of having a bad token set if things fail.\n      var oldToken = Accounts._getLoginToken(self.connection.id);\n      Accounts._setLoginToken(user._id, self.connection, null);\n      var resetToOldToken = function () {\n        Accounts._setLoginToken(user._id, self.connection, oldToken);\n      };\n\n      try {\n        // Update the user record by:\n        // - Changing the password to the new one\n        // - Forgetting about the reset token that was just used\n        // - Verifying their email, since they got the password reset via email.\n        var affectedRecords = Meteor.users.update(\n          {\n            _id: user._id,\n            'emails.address': email,\n            'services.password.reset.token': token\n          },\n          {$set: {'services.password.bcrypt': hashed,\n                  'emails.$.verified': true},\n           $unset: {'services.password.reset': 1,\n                    'services.password.srp': 1}});\n        if (affectedRecords !== 1)\n          return {\n            userId: user._id,\n            error: new Meteor.Error(403, \"Invalid email\")\n          };\n      } catch (err) {\n        resetToOldToken();\n        throw err;\n      }\n\n      // Replace all valid login tokens with new ones (changing\n      // password should invalidate existing sessions).\n      Accounts._clearAllLoginTokens(user._id);\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n///\n/// EMAIL VERIFICATION\n///\n\n\n// send the user an email with a link that when opened marks that\n// address as verified\n\n/**\n * @summary Send an email with a link the user can use verify their email address.\n * @locus Server\n * @param {String} userId The id of the user to send email to.\n * @param {String} [email] Optional. Which address of the user's to send the email to. This address must be in the user's `emails` list. Defaults to the first unverified email in the list.\n * @param {Object} [extraTokenData] Optional additional data to be added into the token record.\n * @returns {Object} Object with {email, user, token, url, options} values.\n * @importFromPackage accounts-base\n */\nAccounts.sendVerificationEmail = function (userId, email, extraTokenData) {\n  // XXX Also generate a link using which someone can delete this\n  // account if they own said address but weren't those who created\n  // this account.\n\n  const {email: realEmail, user, token} =\n    Accounts.generateVerificationToken(userId, email, extraTokenData);\n  const url = Accounts.urls.verifyEmail(token);\n  const options = Accounts.generateOptionsForEmail(realEmail, user, url, 'verifyEmail');\n  Email.send(options);\n  return {email: realEmail, user, token, url, options};\n};\n\n// Take token from sendVerificationEmail, mark the email as verified,\n// and log them in.\nMeteor.methods({verifyEmail: function (token) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"verifyEmail\",\n    arguments,\n    \"password\",\n    function () {\n      check(token, String);\n\n      var user = Meteor.users.findOne(\n        {'services.email.verificationTokens.token': token});\n      if (!user)\n        throw new Meteor.Error(403, \"Verify email link expired\");\n\n      var tokenRecord = _.find(user.services.email.verificationTokens,\n                               function (t) {\n                                 return t.token == token;\n                               });\n      if (!tokenRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link expired\")\n        };\n\n      var emailsRecord = _.find(user.emails, function (e) {\n        return e.address == tokenRecord.address;\n      });\n      if (!emailsRecord)\n        return {\n          userId: user._id,\n          error: new Meteor.Error(403, \"Verify email link is for unknown address\")\n        };\n\n      // By including the address in the query, we can use 'emails.$' in the\n      // modifier to get a reference to the specific object in the emails\n      // array. See\n      // http://www.mongodb.org/display/DOCS/Updating/#Updating-The%24positionaloperator)\n      // http://www.mongodb.org/display/DOCS/Updating#Updating-%24pull\n      Meteor.users.update(\n        {_id: user._id,\n         'emails.address': tokenRecord.address},\n        {$set: {'emails.$.verified': true},\n         $pull: {'services.email.verificationTokens': {address: tokenRecord.address}}});\n\n      return {userId: user._id};\n    }\n  );\n}});\n\n/**\n * @summary Add an email address for a user. Use this instead of directly\n * updating the database. The operation will fail if there is a different user\n * with an email only differing in case. If the specified user has an existing\n * email only differing in case however, we replace it.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} newEmail A new email address for the user.\n * @param {Boolean} [verified] Optional - whether the new email address should\n * be marked as verified. Defaults to false.\n * @importFromPackage accounts-base\n */\nAccounts.addEmail = function (userId, newEmail, verified) {\n  check(userId, NonEmptyString);\n  check(newEmail, NonEmptyString);\n  check(verified, Match.Optional(Boolean));\n\n  if (_.isUndefined(verified)) {\n    verified = false;\n  }\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  // Allow users to change their own email to a version with a different case\n\n  // We don't have to call checkForCaseInsensitiveDuplicates to do a case\n  // insensitive check across all emails in the database here because: (1) if\n  // there is no case-insensitive duplicate between this user and other users,\n  // then we are OK and (2) if this would create a conflict with other users\n  // then there would already be a case-insensitive duplicate and we can't fix\n  // that in this code anyway.\n  var caseInsensitiveRegExp =\n    new RegExp('^' + Meteor._escapeRegExp(newEmail) + '$', 'i');\n\n  var didUpdateOwnEmail = _.any(user.emails, function(email, index) {\n    if (caseInsensitiveRegExp.test(email.address)) {\n      Meteor.users.update({\n        _id: user._id,\n        'emails.address': email.address\n      }, {$set: {\n        'emails.$.address': newEmail,\n        'emails.$.verified': verified\n      }});\n      return true;\n    }\n\n    return false;\n  });\n\n  // In the other updates below, we have to do another call to\n  // checkForCaseInsensitiveDuplicates to make sure that no conflicting values\n  // were added to the database in the meantime. We don't have to do this for\n  // the case where the user is updating their email address to one that is the\n  // same as before, but only different because of capitalization. Read the\n  // big comment above to understand why.\n\n  if (didUpdateOwnEmail) {\n    return;\n  }\n\n  // Perform a case insensitive check for duplicates before update\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n\n  Meteor.users.update({\n    _id: user._id\n  }, {\n    $addToSet: {\n      emails: {\n        address: newEmail,\n        verified: verified\n      }\n    }\n  });\n\n  // Perform another check after update, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', newEmail, user._id);\n  } catch (ex) {\n    // Undo update if the check fails\n    Meteor.users.update({_id: user._id},\n      {$pull: {emails: {address: newEmail}}});\n    throw ex;\n  }\n}\n\n/**\n * @summary Remove an email address for a user. Use this instead of updating\n * the database directly.\n * @locus Server\n * @param {String} userId The ID of the user to update.\n * @param {String} email The email address to remove.\n * @importFromPackage accounts-base\n */\nAccounts.removeEmail = function (userId, email) {\n  check(userId, NonEmptyString);\n  check(email, NonEmptyString);\n\n  var user = Meteor.users.findOne(userId);\n  if (!user)\n    throw new Meteor.Error(403, \"User not found\");\n\n  Meteor.users.update({_id: user._id},\n    {$pull: {emails: {address: email}}});\n}\n\n///\n/// CREATING USERS\n///\n\n// Shared createUser function called from the createUser method, both\n// if originates in client or server code. Calls user provided hooks,\n// does the actual user insertion.\n//\n// returns the user id\nvar createUser = function (options) {\n  // Unknown keys allowed, because a onCreateUserHook can take arbitrary\n  // options.\n  check(options, Match.ObjectIncluding({\n    username: Match.Optional(String),\n    email: Match.Optional(String),\n    password: Match.Optional(passwordValidator)\n  }));\n\n  var username = options.username;\n  var email = options.email;\n  if (!username && !email)\n    throw new Meteor.Error(400, \"Need to set a username or email\");\n\n  var user = {services: {}};\n  if (options.password) {\n    var hashed = hashPassword(options.password);\n    user.services.password = { bcrypt: hashed };\n  }\n\n  if (username)\n    user.username = username;\n  if (email)\n    user.emails = [{address: email, verified: false}];\n\n  // Perform a case insensitive check before insert\n  checkForCaseInsensitiveDuplicates('username', 'Username', username);\n  checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n  var userId = Accounts.insertUserDoc(options, user);\n  // Perform another check after insert, in case a matching user has been\n  // inserted in the meantime\n  try {\n    checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n    checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n  } catch (ex) {\n    // Remove inserted user if the check fails\n    Meteor.users.remove(userId);\n    throw ex;\n  }\n  return userId;\n};\n\n// method for create user. Requests come from the client.\nMeteor.methods({createUser: function (options) {\n  var self = this;\n  return Accounts._loginMethod(\n    self,\n    \"createUser\",\n    arguments,\n    \"password\",\n    function () {\n      // createUser() above does more checking.\n      check(options, Object);\n      if (Accounts._options.forbidClientAccountCreation)\n        return {\n          error: new Meteor.Error(403, \"Signups forbidden\")\n        };\n\n      // Create user. result contains id and token.\n      var userId = createUser(options);\n      // safety belt. createUser is supposed to throw on error. send 500 error\n      // instead of sending a verification email with empty userid.\n      if (! userId)\n        throw new Error(\"createUser failed to insert new user\");\n\n      // If `Accounts._options.sendVerificationEmail` is set, register\n      // a token to verify the user's primary email, and send it to\n      // that address.\n      if (options.email && Accounts._options.sendVerificationEmail)\n        Accounts.sendVerificationEmail(userId, options.email);\n\n      // client gets logged in as the new user afterwards.\n      return {userId: userId};\n    }\n  );\n}});\n\n// Create user directly on the server.\n//\n// Unlike the client version, this does not log you in as this user\n// after creation.\n//\n// returns userId or throws an error if it can't create\n//\n// XXX add another argument (\"server options\") that gets sent to onCreateUser,\n// which is always empty when called from the createUser method? eg, \"admin:\n// true\", which we want to prevent the client from setting, but which a custom\n// method calling Accounts.createUser could set?\n//\nAccounts.createUser = function (options, callback) {\n  options = _.clone(options);\n\n  // XXX allow an optional callback?\n  if (callback) {\n    throw new Error(\"Accounts.createUser with callback not supported on the server yet.\");\n  }\n\n  return createUser(options);\n};\n\n///\n/// PASSWORD-SPECIFIC INDEXES ON USERS\n///\nMeteor.users._ensureIndex('services.email.verificationTokens.token',\n                          {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.password.reset.token',\n                          {unique: 1, sparse: 1});\n"]}}]