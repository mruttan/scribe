{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/practicalmeteor:mocha/lib/runner.js","filenameRelative":"packages/practicalmeteor:mocha/lib/runner.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/practicalmeteor:mocha/lib/runner.js.map","sourceFileName":"packages/practicalmeteor:mocha/lib/runner.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"runner"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\n * Module dependencies.\n */var EventEmitter = require('events').EventEmitter;\n\nvar Pending = require('./pending');\n\nvar utils = require('./utils');\n\nvar inherits = utils.inherits;\n\nvar debug = require('debug')('mocha:runner');\n\nvar Runnable = require('./runnable');\n\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray; /**\n                              * Non-enumerable globals.\n                              */\nvar globals = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'XMLHttpRequest', 'Date', 'setImmediate', 'clearImmediate']; /**\n                                                                                                                                           * Expose `Runner`.\n                                                                                                                                           */\nmodule.exports = Runner; /**\n                          * Initialize a `Runner` for the given `suite`.\n                          *\n                          * Events:\n                          *\n                          *   - `start`  execution started\n                          *   - `end`  execution complete\n                          *   - `suite`  (suite) test suite execution started\n                          *   - `suite end`  (suite) all tests (and sub-suites) have finished\n                          *   - `test`  (test) test execution started\n                          *   - `test end`  (test) test completed\n                          *   - `hook`  (hook) hook execution started\n                          *   - `hook end`  (hook) hook complete\n                          *   - `pass`  (test) test passed\n                          *   - `fail`  (test, err) test failed\n                          *   - `pending`  (test) test pending\n                          *\n                          * @api public\n                          * @param {Suite} suite Root suite\n                          * @param {boolean} [delay] Whether or not to delay execution of root suite\n                          * until ready.\n                          */\n\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n} /**\n   * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n   *\n   * @param {Function} fn\n   * @api private\n   */\n\nRunner.immediately = global.setImmediate || process.nextTick; /**\n                                                               * Inherit from `EventEmitter.prototype`.\n                                                               */\ninherits(Runner, EventEmitter); /**\n                                 * Run tests with full titles matching `re`. Updates runner.total\n                                 * with number of tests matched.\n                                 *\n                                 * @param {RegExp} re\n                                 * @param {Boolean} invert\n                                 * @return {Runner} for chaining\n                                 * @api public\n                                 * @param {RegExp} re\n                                 * @param {boolean} invert\n                                 * @return {Runner} Runner instance.\n                                 */\n\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n}; /**\n    * Returns the number of tests matching the grep search for the\n    * given suite.\n    *\n    * @param {Suite} suite\n    * @return {Number}\n    * @api public\n    * @param {Suite} suite\n    * @return {number}\n    */\n\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (match) {\n      total++;\n    }\n  });\n  return total;\n}; /**\n    * Return a list of global properties.\n    *\n    * @return {Array}\n    * @api private\n    */\n\nRunner.prototype.globalProps = function () {\n  var props = keys(global); // non-enumerables\n\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n\n    props.push(globals[i]);\n  }\n\n  return props;\n}; /**\n    * Allow the given `arr` of globals.\n    *\n    * @param {Array} arr\n    * @return {Runner} for chaining\n    * @api public\n    * @param {Array} arr\n    * @return {Runner} Runner instance.\n    */\n\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n}; /**\n    * Check for global variable leaks.\n    *\n    * @api private\n    */\n\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n\n  var ok = this._globals;\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n\n  this.prevGlobalsLength = globals.length;\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n}; /**\n    * Fail the given `test`.\n    *\n    * @api private\n    * @param {Test} test\n    * @param {Error} err\n    */\n\nRunner.prototype.fail = function (test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  this.emit('fail', test, err);\n}; /**\n    * Fail the given `hook` with `err`.\n    *\n    * Hook failures work in the following pattern:\n    * - If bail, then exit\n    * - Failed `before` hook skips all tests in a suite and subsuites,\n    *   but jumps to corresponding `after` hook\n    * - Failed `before each` hook skips remaining tests in a\n    *   suite and jumps to corresponding `after each` hook,\n    *   which is run only once\n    * - Failed `after` hook does not alter\n    *   execution order\n    * - Failed `after each` hook skips remaining tests in a\n    *   suite and subsuites, but executes other `after each`\n    *   hooks\n    *\n    * @api private\n    * @param {Hook} hook\n    * @param {Error} err\n    */\n\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n}; /**\n    * Run hook `name` callbacks and then invoke `fn()`.\n    *\n    * @api private\n    * @param {string} name\n    * @param {Function} fn\n    */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n\n    if (!hook) {\n      return fn();\n    }\n\n    self.currentRunnable = hook;\n    hook.ctx.currentTest = self.test;\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err); // stop executing hooks, notify callee of hook err\n\n          return fn(err);\n        }\n      }\n\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n}; /**\n    * Run hook `name` for the given array of `suites`\n    * in order, and callback `fn(err, errSuite)`.\n    *\n    * @api private\n    * @param {string} name\n    * @param {Array} suites\n    * @param {Function} fn\n    */\n\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n}; /**\n    * Run hooks from the top level down.\n    *\n    * @param {String} name\n    * @param {Function} fn\n    * @api private\n    */\n\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n}; /**\n    * Run hooks from the bottom up.\n    *\n    * @param {String} name\n    * @param {Function} fn\n    * @api private\n    */\n\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n}; /**\n    * Return an array of parent Suites from\n    * closest to furthest.\n    *\n    * @return {Array}\n    * @api private\n    */\n\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n\n  return suites;\n}; /**\n    * Run the current test and callback `fn(err)`.\n    *\n    * @param {Function} fn\n    * @api private\n    */\n\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n\n  try {\n    test.on('error', function (err) {\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n}; /**\n    * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n    *\n    * @api private\n    * @param {Suite} suite\n    * @param {Function} fn\n    */\n\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite; // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig; // some hooks may fail even now\n\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        } // report error suite\n\n\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    } // next test\n\n\n    test = tests.shift(); // all done\n\n    if (!test) {\n      return fn();\n    } // grep\n\n\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n\n      return;\n    }\n\n    function parentPending(suite) {\n      return suite.pending || suite.parent && parentPending(suite.parent);\n    } // pending\n\n\n    if (test.pending || parentPending(test.parent)) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    } // execute test and hook(s)\n\n\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n\n        if (err) {\n          var retry = test.currentRetry();\n\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest); // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n}; /**\n    * Run the given `suite` and invoke the callback `fn()` when complete.\n    *\n    * @api private\n    * @param {Suite} suite\n    * @param {Function} fn\n    */\n\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || self.failures && suite._bail) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n\n\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n\n    if (!curr) {\n      return done();\n    } // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n\n\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true; // remove reference to test\n\n      delete self.test;\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n\n    self.runTests(suite, next);\n  });\n}; /**\n    * Handle uncaught exceptions.\n    *\n    * @param {Error} err\n    * @api private\n    */\n\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err !== function () {\n      return this;\n    }.call(err) ? err : err.message || err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n\n  err.uncaught = true;\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout(); // Ignore errors if complete\n\n  if (runnable.state) {\n    return;\n  }\n\n  this.fail(runnable, err); // recover from test\n\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  } // recover from hooks\n\n\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite; // if hook failure is in afterEach block\n\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    } // if hook failure is in beforeEach block\n\n\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    } // if hook failure is in after or before blocks\n\n\n    return this.nextSuite(errSuite);\n  } // bail\n\n\n  this.emit('end');\n}; /**\n    * Cleans up the references to all the deferred functions\n    * (before/after/beforeEach/afterEach) and tests of a Suite.\n    * These must be deleted otherwise a memory leak can happen,\n    * as those functions may reference variables from closures,\n    * thus those variables can never be garbage collected as long\n    * as the deferred functions exist.\n    *\n    * @param {Suite} suite\n    */\n\nfunction cleanSuiteReferences(suite) {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n} /**\n   * Run the root suite and invoke `fn(failures)`\n   * on completion.\n   *\n   * @param {Function} fn\n   * @return {Runner} for chaining\n   * @api public\n   * @param {Function} fn\n   * @return {Runner} Runner instance.\n   */\n\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function () {};\n\n  function uncaught(err) {\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start'); // references cleanup to avoid memory leaks\n\n  this.on('suite end', cleanSuiteReferences); // callback\n\n  this.on('end', function () {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  }); // uncaught exception\n\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n}; /**\n    * Cleanly abort execution.\n    *\n    * @api public\n    * @return {Runner} Runner instance.\n    */\n\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n  return this;\n}; /**\n    * Filter leaks with the given globals flagged as `ok`.\n    *\n    * @api private\n    * @param {Array} ok\n    * @param {Array} globals\n    * @return {Array}\n    */\n\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) {\n      return false;\n    } // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n\n\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    } // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n\n\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    } // Opera and IE expose global variables for HTML element IDs (issue #243)\n\n\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n} /**\n   * Array of globals dependent on the environment.\n   *\n   * @return {Array}\n   * @api private\n   */\n\nfunction extraGlobals() {\n  if ((typeof process === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(process)) === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function (a, v) {\n      return a << 8 | v;\n    }); // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}","map":{"version":3,"sources":["packages/practicalmeteor:mocha/lib/runner.js"],"names":["EventEmitter","require","Pending","utils","inherits","debug","Runnable","filter","indexOf","keys","stackFilter","stackTraceFilter","stringify","type","undefinedError","isArray","globals","module","exports","Runner","suite","delay","self","_globals","_abort","_delay","started","total","failures","on","test","checkGlobals","hook","_defaultGrep","grep","globalProps","concat","extraGlobals","immediately","global","setImmediate","process","nextTick","prototype","re","invert","_grep","_invert","grepTotal","eachTest","match","fullTitle","props","i","length","push","arr","arguments","ignoreLeaks","ok","leaks","_allowedGlobals","prevGlobalsLength","filterLeaks","fail","Error","join","err","state","message","stack","fullStackTrace","emit","failHook","ctx","currentTest","originalTitle","title","bail","name","fn","hooks","next","currentRunnable","listeners","run","testError","error","pending","suites","orig","errSuite","pop","hookUp","parents","reverse","hookDown","parent","runTest","asyncOnly","allowUncaught","runTests","tests","slice","hookErr","_","after","err2","errSuite2","_bail","shift","parentPending","retry","currentRetry","retries","clonedTest","clone","unshift","runSuite","afterAllHookCalled","done","curr","nextSuite","uncaught","call","runnable","clearTimeout","cleanSuiteReferences","cleanArrReferences","_beforeAll","_beforeEach","_afterAll","_afterEach","rootSuite","start","removeListener","once","abort","key","navigator","matched","split","version","parts","nodeVersion","reduce","a","v"],"mappings":"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","file":"packages/practicalmeteor:mocha/lib/runner.js.map","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar filter = utils.filter;\nvar indexOf = utils.indexOf;\nvar keys = utils.keys;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\nvar isArray = utils.isArray;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`.\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @api public\n * @param {Suite} suite Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner(suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function(test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function(hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @param {RegExp} re\n * @param {Boolean} invert\n * @return {Runner} for chaining\n * @api public\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function(re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @param {Suite} suite\n * @return {Number}\n * @api public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function() {\n  var props = keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~indexOf(props, globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @param {Array} arr\n * @return {Runner} for chaining\n * @api public\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function(arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function(test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function(test, err) {\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || err && typeof err.message === 'string')) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  err.stack = (this.fullStackTrace || !err.stack)\n    ? err.stack\n    : stackFilter(err.stack);\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function(hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  this.fail(hook, err);\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function(name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function(err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          suite.pending = true;\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function() {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function(name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function(name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function(name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function() {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function(fn) {\n  var self = this;\n  var test = this.test;\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.on('error', function(err) {\n      self.fail(test, err);\n    });\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function(suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep — It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    function parentPending(suite) {\n      return suite.pending || (suite.parent && parentPending(suite.parent));\n    }\n\n    // pending\n    if (test.pending || parentPending(test.parent)) {\n      self.emit('pending', test);\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function(err, errSuite) {\n      if (suite.pending) {\n        self.emit('pending', test);\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function(err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function(suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function() {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function() {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function(err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function(err) {\n  if (err) {\n    debug('uncaught exception %s', err !== function() {\n      return this;\n    }.call(err) ? err : (err.message || err));\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if complete\n  if (runnable.state) {\n    return;\n  }\n  this.fail(runnable, err);\n\n  // recover from test\n  if (runnable.type === 'test') {\n    this.emit('test end', runnable);\n    this.hookUp('afterEach', this.next);\n    return;\n  }\n\n // recover from hooks\n  if (runnable.type === 'hook') {\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences(suite) {\n  function cleanArrReferences(arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @param {Function} fn\n * @return {Runner} for chaining\n * @api public\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function(fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function() {};\n\n  function uncaught(err) {\n    self.uncaught(err);\n  }\n\n  function start() {\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function() {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function() {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function() {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return filter(globals, function(key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method not init at first\n    // it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = filter(ok, function(ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals() {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = utils.reduce(parts, function(a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n"]},"hash":"f40c03edbf0c8ff6bc5d5911ef23c9abc7f38b6d"}
