{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/practicalmeteor:mocha/test/integration/helpers.js","filenameRelative":"packages/practicalmeteor:mocha/test/integration/helpers.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/practicalmeteor:mocha/test/integration/helpers.js.map","sourceFileName":"packages/practicalmeteor:mocha/test/integration/helpers.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"helpers"},"ignored":false,"code":"var spawn = require('child_process').spawn;\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nmodule.exports = {\n  /**\n   * Invokes the mocha binary for the given fixture with color output disabled.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */runMocha: function (fixturePath, args, fn) {\n    var path;\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n    invokeMocha(args.concat(['-C', path]), function (err, res) {\n      if (err) return fn(err);\n      fn(null, getSummary(res));\n    });\n  },\n  /**\n   * Invokes the mocha binary on the code of the body of the function.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {function} fixture\n   * @param {array}    args\n   * @param {function} fn\n   */runMochaFunction: function (fixture, args, fn) {\n    var path = resolveFixturePath(fixture.name + '.js' || 'tempfile.js');\n    args = args || [];\n    var fixtureContent = 'var fn = ' + fixture.toString() + '; fn()';\n    fs.writeFileSync(path, fixtureContent, 'utf8');\n\n    function cleanup() {\n      fs.unlink(path);\n      fn.apply(this, arguments);\n    }\n\n    invokeMocha(args.concat(['-C', path]), function (err, res) {\n      if (err) {\n        return cleanup(err);\n      }\n\n      cleanup(null, getSummary(res));\n    });\n  },\n  /**\n   * Invokes the mocha binary for the given fixture using the JSON reporter,\n   * returning the parsed output, as well as exit code.\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */runMochaJSON: function (fixturePath, args, fn) {\n    var path;\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n    invokeMocha(args.concat(['--reporter', 'json', path]), function (err, res) {\n      if (err) return fn(err);\n\n      try {\n        var result = JSON.parse(res.output);\n        result.code = res.code;\n      } catch (err) {\n        return fn(err);\n      }\n\n      fn(null, result);\n    });\n  },\n  /**\n   * Returns an array of diffs corresponding to exceptions thrown from specs,\n   * given the plaintext output (-C) of a mocha run.\n   *\n   * @param  {string}   output\n   * returns {string[]}\n   */getDiffs: function (output) {\n    var diffs, i, inDiff, inStackTrace;\n    diffs = [];\n    output.split('\\n').forEach(function (line) {\n      if (line.match(/^  \\d+\\)/)) {\n        // New spec, e.g. \"1) spec title\"\n        diffs.push([]);\n        i = diffs.length - 1;\n        inStackTrace = false;\n        inDiff = false;\n      } else if (!diffs.length || inStackTrace) {\n        // Haven't encountered a spec yet\n        // or we're in the middle of a stack trace\n        return;\n      } else if (line.indexOf('+ expected - actual') !== -1) {\n        inDiff = true;\n      } else if (line.match(/at Context/)) {\n        // At the start of a stack trace\n        inStackTrace = true;\n        inDiff = false;\n      } else if (inDiff) {\n        diffs[i].push(line);\n      }\n    }); // Ignore empty lines before/after diff\n\n    return diffs.map(function (diff) {\n      return diff.slice(1, -3).join('\\n');\n    });\n  }\n};\n\nfunction invokeMocha(args, fn) {\n  var output, mocha, listener;\n  output = '';\n  mocha = spawn('./bin/mocha', args);\n\n  listener = function (data) {\n    output += data;\n  };\n\n  mocha.stdout.on('data', listener);\n  mocha.stderr.on('data', listener);\n  mocha.on('error', fn);\n  mocha.on('close', function (code) {\n    fn(null, {\n      output: output.split('\\n').join('\\n'),\n      code: code\n    });\n  });\n}\n\nfunction resolveFixturePath(fixture) {\n  return path.join('./test/integration/fixtures', fixture);\n}\n\nfunction getSummary(res) {\n  return ['passing', 'pending', 'failing'].reduce(function (summary, type) {\n    var pattern, match;\n    pattern = new RegExp('  (\\\\d+) ' + type + '\\\\s');\n    match = pattern.exec(res.output);\n    summary[type] = match ? parseInt(match, 10) : 0;\n    return summary;\n  }, res);\n}","map":{"version":3,"sources":["packages/practicalmeteor:mocha/test/integration/helpers.js"],"names":["spawn","require","path","fs","module","exports","runMocha","fixturePath","args","fn","resolveFixturePath","invokeMocha","concat","err","res","getSummary","runMochaFunction","fixture","name","fixtureContent","toString","writeFileSync","cleanup","unlink","apply","arguments","runMochaJSON","result","JSON","parse","output","code","getDiffs","diffs","i","inDiff","inStackTrace","split","forEach","line","match","push","length","indexOf","map","diff","slice","join","mocha","listener","data","stdout","on","stderr","reduce","summary","type","pattern","RegExp","exec","parseInt"],"mappings":"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","file":"packages/practicalmeteor:mocha/test/integration/helpers.js.map","sourcesContent":["var spawn = require('child_process').spawn;\nvar path  = require('path');\nvar fs = require('fs');\n\nmodule.exports = {\n  /**\n   * Invokes the mocha binary for the given fixture with color output disabled.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMocha: function(fixturePath, args, fn) {\n    var path;\n\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n\n    invokeMocha(args.concat(['-C', path]), function(err, res) {\n      if (err) return fn(err);\n\n      fn(null, getSummary(res));\n    });\n  },\n\n  /**\n   * Invokes the mocha binary on the code of the body of the function.\n   * Accepts an array of additional command line args to pass. The callback is\n   * invoked with a summary of the run, in addition to its output. The summary\n   * includes the number of passing, pending, and failing tests, as well as the\n   * exit code. Useful for testing different reporters.\n   *\n   * Example response:\n   * {\n   *   pending: 0,\n   *   passing: 0,\n   *   failing: 1,\n   *   code:    1,\n   *   output:  '...'\n   * }\n   *\n   * @param {function} fixture\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaFunction: function(fixture, args, fn) {\n    var path = resolveFixturePath(fixture.name + '.js' || 'tempfile.js');\n    args = args || [];\n\n    var fixtureContent = 'var fn = ' + fixture.toString() + '; fn()';\n    fs.writeFileSync(path, fixtureContent, 'utf8');\n\n    function cleanup() {\n      fs.unlink(path);\n      fn.apply(this, arguments);\n    }\n\n    invokeMocha(args.concat(['-C', path]), function(err, res) {\n      if (err) {\n        return cleanup(err);\n      }\n\n      cleanup(null, getSummary(res));\n    });\n  },\n\n  /**\n   * Invokes the mocha binary for the given fixture using the JSON reporter,\n   * returning the parsed output, as well as exit code.\n   *\n   * @param {string}   fixturePath\n   * @param {array}    args\n   * @param {function} fn\n   */\n  runMochaJSON: function(fixturePath, args, fn) {\n    var path;\n\n    path = resolveFixturePath(fixturePath);\n    args = args || [];\n\n    invokeMocha(args.concat(['--reporter', 'json', path]), function(err, res) {\n      if (err) return fn(err);\n\n      try {\n        var result = JSON.parse(res.output);\n        result.code = res.code;\n      } catch (err) {\n        return fn(err);\n      }\n\n      fn(null, result);\n    });\n  },\n\n  /**\n   * Returns an array of diffs corresponding to exceptions thrown from specs,\n   * given the plaintext output (-C) of a mocha run.\n   *\n   * @param  {string}   output\n   * returns {string[]}\n   */\n  getDiffs: function(output) {\n    var diffs, i, inDiff, inStackTrace;\n\n    diffs = [];\n    output.split('\\n').forEach(function(line) {\n      if (line.match(/^  \\d+\\)/)) {\n        // New spec, e.g. \"1) spec title\"\n        diffs.push([]);\n        i = diffs.length - 1;\n        inStackTrace = false;\n        inDiff = false;\n      } else if (!diffs.length || inStackTrace) {\n        // Haven't encountered a spec yet\n        // or we're in the middle of a stack trace\n        return;\n      } else if (line.indexOf('+ expected - actual') !== -1) {\n        inDiff = true;\n      } else if (line.match(/at Context/)) {\n        // At the start of a stack trace\n        inStackTrace = true;\n        inDiff = false;\n      } else if (inDiff) {\n        diffs[i].push(line);\n      }\n    });\n\n    // Ignore empty lines before/after diff\n    return diffs.map(function(diff) {\n      return diff.slice(1, -3).join('\\n');\n    });\n  }\n};\n\nfunction invokeMocha(args, fn) {\n  var output, mocha, listener;\n\n  output = '';\n  mocha = spawn('./bin/mocha', args);\n\n  listener = function(data) {\n    output += data;\n  };\n\n  mocha.stdout.on('data', listener);\n  mocha.stderr.on('data', listener);\n  mocha.on('error', fn);\n\n  mocha.on('close', function(code) {\n    fn(null, {\n      output: output.split('\\n').join('\\n'),\n      code: code\n    });\n  });\n}\n\nfunction resolveFixturePath(fixture) {\n  return path.join('./test/integration/fixtures', fixture);\n}\n\nfunction getSummary(res) {\n  return ['passing', 'pending', 'failing'].reduce(function(summary, type) {\n    var pattern, match;\n\n    pattern = new RegExp('  (\\\\d+) ' + type + '\\\\s');\n    match = pattern.exec(res.output);\n    summary[type] = (match) ? parseInt(match, 10) : 0;\n\n    return summary;\n  }, res);\n}\n"]},"hash":"5ac416598e3d4e162103d4b07e311be4f1688856"}
