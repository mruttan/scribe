{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"fibers","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Fiber"}]},{"source":"./setup","imported":[],"specifiers":[]},{"source":"mocha","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"Mocha"}]},{"source":"./cleanup","imported":[],"specifiers":[]}],"exports":{"exported":["mochaInstance","setupGlobals","Mocha"],"specifiers":[{"kind":"local","local":"mochaInstance","exported":"mochaInstance"},{"kind":"local","local":"setupGlobals","exported":"setupGlobals"},{"kind":"local","local":"Mocha","exported":"Mocha"}]}}},"options":{"filename":"packages/practicalmeteor:mocha-core/server.js","filenameRelative":"packages/practicalmeteor:mocha-core/server.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/practicalmeteor:mocha-core/server.js.map","sourceFileName":"packages/practicalmeteor:mocha-core/server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"server"},"ignored":false,"code":"module.export({\n  mochaInstance: function () {\n    return mochaInstance;\n  },\n  setupGlobals: function () {\n    return setupGlobals;\n  },\n  Mocha: function () {\n    return Mocha;\n  }\n});\nvar Fiber = void 0;\nmodule.watch(require(\"fibers\"), {\n  \"default\": function (v) {\n    Fiber = v;\n  }\n}, 0);\nmodule.watch(require(\"./setup\"));\nvar Mocha = void 0;\nmodule.watch(require(\"mocha\"), {\n  \"default\": function (v) {\n    Mocha = v;\n  }\n}, 1);\nmodule.watch(require(\"./cleanup\"));\n\nfunction setupGlobals(mocha) {\n  var mochaExports = {};\n  mocha.suite.emit('pre-require', mochaExports, undefined, mocha); // 1. patch up it and hooks functions so it plays nice w/ fibers\n  // 2. trick to allow binding the suite instance as `this` value\n  // inside of suites blocks, to allow e.g. to set custom timeouts.\n\n  var wrapRunnable = function (fn) {\n    //In Meteor, these blocks will all be invoking Meteor code and must\n    //run within a fiber. We must therefore wrap each with something like\n    //bindEnvironment. The function passed off to mocha must have length\n    //greater than zero if we want mocha to run it asynchronously. That's\n    //why it uses the Fibers\n    //We're actually having mocha run all tests asynchronously. This\n    //is because mocha cannot tell when a synchronous fiber test has\n    //finished, because the test runner runs outside a fiber.\n    //It is possible that the mocha test runner could be run from within a\n    //fiber, but it was unclear to me how that could be done without\n    //forking mocha itself.\n    var wrappedFunction = function (done) {\n      var self = this._runnable;\n\n      var run = function () {\n        try {\n          // Sync call\n          if (fn.length == 0) {\n            var result = fn.call(self);\n\n            if (result && typeof result.then === 'function') {\n              self.resetTimeout();\n              result.then(function () {\n                done(); // Return null so libraries like bluebird do not warn about\n                // subsequently constructed Promises.\n\n                return null;\n              }, function (reason) {\n                done(reason || new Error('Promise rejected with no or falsy reason'));\n              });\n            } else {\n              if (self.asyncOnly) {\n                return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n              }\n\n              done();\n            }\n          } else {\n            fn.call(self, done);\n          }\n        } catch (error) {\n          done(error);\n        }\n      };\n\n      if (Fiber.current) return run();\n      Fiber(run).run();\n    }; // Show original function source code\n\n\n    wrappedFunction.toString = function () {\n      return fn.toString();\n    };\n\n    return wrappedFunction;\n  };\n\n  mochaExports[\"__org_it\"] = mochaExports[\"it\"];\n\n  mochaExports['it'] = function (name, func) {\n    // You can create pending tests without a function\n    // http://mochajs.org/#pending-tests\n    // i.e pending test\n    // it('this is a pending test');\n    if (func) {\n      func = wrapRunnable(func);\n    }\n\n    return mochaExports[\"__org_it\"](name, func);\n  };\n\n  mochaExports.it.skip = mochaExports[\"__org_it\"].skip;\n\n  mochaExports.it.only = function (name, func) {\n    mochaExports[\"__org_it\"].only(name, wrapRunnable(func));\n  };\n\n  var hooks = [\"before\", \"beforeEach\", \"after\", \"afterEach\"];\n  hooks.forEach(function (hook) {\n    mochaExports[\"__org_\" + hook] = mochaExports[hook];\n\n    mochaExports[hook] = function (func) {\n      return mochaExports[\"__org_\" + hook](wrapRunnable(func));\n    };\n  });\n  Object.keys(mochaExports).forEach(function (key) {\n    // We don't want original function to be export to global namespace\n    if (key.indexOf(\"__org_\") > -1 || key.indexOf(\"run\") > -1) {\n      return;\n    }\n\n    global[key] = mochaExports[key];\n  });\n}\n\n; // Initialize a new `Mocha` test runner instance that test driver packages\n// can use to ensure they work well with other test driver packages.\n\nvar mochaInstance = new Mocha({\n  ui: 'bdd',\n  ignoreLeaks: true\n});\nsetupGlobals(mochaInstance);","map":{"version":3,"sources":["packages/practicalmeteor:mocha-core/server.js"],"names":["module","export","mochaInstance","setupGlobals","Mocha","Fiber","watch","require","v","mocha","mochaExports","suite","emit","undefined","wrapRunnable","fn","wrappedFunction","done","self","_runnable","run","length","result","call","then","resetTimeout","reason","Error","asyncOnly","error","current","toString","name","func","it","skip","only","hooks","forEach","hook","Object","keys","key","indexOf","global","ui","ignoreLeaks"],"mappings":"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","file":"packages/practicalmeteor:mocha-core/server.js.map","sourcesContent":["import Fiber from 'fibers';\nimport \"./setup\"\nimport Mocha from 'mocha';\nimport \"./cleanup\"\n\nfunction setupGlobals(mocha) {\n  var mochaExports = {};\n  mocha.suite.emit('pre-require', mochaExports, undefined, mocha);\n\n  // 1. patch up it and hooks functions so it plays nice w/ fibers\n  // 2. trick to allow binding the suite instance as `this` value\n  // inside of suites blocks, to allow e.g. to set custom timeouts.\n  var wrapRunnable = function (fn) {\n    //In Meteor, these blocks will all be invoking Meteor code and must\n    //run within a fiber. We must therefore wrap each with something like\n    //bindEnvironment. The function passed off to mocha must have length\n    //greater than zero if we want mocha to run it asynchronously. That's\n    //why it uses the Fibers\n\n    //We're actually having mocha run all tests asynchronously. This\n    //is because mocha cannot tell when a synchronous fiber test has\n    //finished, because the test runner runs outside a fiber.\n\n    //It is possible that the mocha test runner could be run from within a\n    //fiber, but it was unclear to me how that could be done without\n    //forking mocha itself.\n\n    const wrappedFunction = function (done) {\n      var self = this._runnable;\n      var run = function() {\n        try {\n          // Sync call\n          if (fn.length == 0) {\n            var result = fn.call(self);\n            if (result && typeof result.then === 'function') {\n              self.resetTimeout();\n              result\n                .then(function() {\n                    done();\n                    // Return null so libraries like bluebird do not warn about\n                    // subsequently constructed Promises.\n                    return null;\n                  },\n                  function(reason) {\n                    done(reason || new Error('Promise rejected with no or falsy reason'));\n                  });\n            } else {\n              if (self.asyncOnly) {\n                return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n              }\n\n              done();\n            }\n          }\n          else {\n            fn.call(self, done);\n          }\n        } catch (error) {\n          done(error);\n        }\n      };\n\n      if (Fiber.current) return run();\n      Fiber(run).run();\n    };\n\n    // Show original function source code\n    wrappedFunction.toString = function () { return fn.toString() };\n    return wrappedFunction;\n  };\n\n  mochaExports[\"__org_it\"] = mochaExports[\"it\"];\n  mochaExports['it'] = function (name, func) {\n    // You can create pending tests without a function\n    // http://mochajs.org/#pending-tests\n    // i.e pending test\n    // it('this is a pending test');\n    if (func) {\n      func = wrapRunnable(func);\n    }\n    return mochaExports[\"__org_it\"](name, func);\n  };\n  mochaExports.it.skip = mochaExports[\"__org_it\"].skip;\n  mochaExports.it.only = (name, func) => {\n    mochaExports[\"__org_it\"].only(name, wrapRunnable(func));\n  };\n\n\n  let hooks = [\"before\", \"beforeEach\", \"after\", \"afterEach\"];\n  hooks.forEach((hook)=> {\n    mochaExports[`__org_${hook}`] = mochaExports[hook];\n    mochaExports[hook] = (func)=> {\n     return  mochaExports[`__org_${hook}`](wrapRunnable(func));\n    }\n  });\n\n  Object.keys(mochaExports).forEach((key)=>{\n    // We don't want original function to be export to global namespace\n    if(key.indexOf(\"__org_\") > -1 || key.indexOf(\"run\") > -1){\n      return;\n    }\n    global[key] = mochaExports[key];\n  })\n\n};\n\n// Initialize a new `Mocha` test runner instance that test driver packages\n// can use to ensure they work well with other test driver packages.\nconst mochaInstance = new Mocha({\n  ui: 'bdd',\n  ignoreLeaks: true\n});\nsetupGlobals(mochaInstance);\n \nexport { mochaInstance, setupGlobals, Mocha };\n"]},"hash":"bc85711e605912c6addc91f888cc5741caa678ba"}
