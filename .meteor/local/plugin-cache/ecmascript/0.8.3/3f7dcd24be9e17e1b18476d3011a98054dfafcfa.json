{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/practicalmeteor:mocha/lib/reporters/json-cov.js","filenameRelative":"packages/practicalmeteor:mocha/lib/reporters/json-cov.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/practicalmeteor:mocha/lib/reporters/json-cov.js.map","sourceFileName":"packages/practicalmeteor:mocha/lib/reporters/json-cov.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"json-cov"},"ignored":false,"code":"/**\n * Module dependencies.\n */var Base = require('./base'); /**\n                                  * Expose `JSONCov`.\n                                  */\n\nexports = module.exports = JSONCov; /**\n                                     * Initialize a new `JsCoverage` reporter.\n                                     *\n                                     * @api public\n                                     * @param {Runner} runner\n                                     * @param {boolean} output\n                                     */\n\nfunction JSONCov(runner, output) {\n  Base.call(this, runner);\n  output = arguments.length === 1 || output;\n  var self = this;\n  var tests = [];\n  var failures = [];\n  var passes = [];\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n  runner.on('end', function () {\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n\n    if (!output) {\n      return;\n    }\n\n    process.stdout.write(JSON.stringify(result, null, 2));\n  });\n} /**\n   * Map jscoverage data to a JSON structure\n   * suitable for reporting.\n   *\n   * @api private\n   * @param {Object} cov\n   * @return {Object}\n   */\n\nfunction map(cov) {\n  var ret = {\n    instrumentation: 'node-jscoverage',\n    sloc: 0,\n    hits: 0,\n    misses: 0,\n    coverage: 0,\n    files: []\n  };\n\n  for (var filename in meteorBabelHelpers.sanitizeForInObject(cov)) {\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\n      var data = coverage(filename, cov[filename]);\n      ret.files.push(data);\n      ret.hits += data.hits;\n      ret.misses += data.misses;\n      ret.sloc += data.sloc;\n    }\n  }\n\n  ret.files.sort(function (a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = ret.hits / ret.sloc * 100;\n  }\n\n  return ret;\n} /**\n   * Map jscoverage data for a single source file\n   * to a JSON structure suitable for reporting.\n   *\n   * @api private\n   * @param {string} filename name of the source file\n   * @param {Object} data jscoverage coverage data\n   * @return {Object}\n   */\n\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n  data.source.forEach(function (line, num) {\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n      source: line,\n      coverage: data[num] === undefined ? '' : data[num]\n    };\n  });\n  ret.coverage = ret.hits / ret.sloc * 100;\n  return ret;\n} /**\n   * Return a plain-object representation of `test`\n   * free of cyclic properties etc.\n   *\n   * @api private\n   * @param {Object} test\n   * @return {Object}\n   */\n\nfunction clean(test) {\n  return {\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    fullTitle: test.fullTitle(),\n    title: test.title\n  };\n}","map":{"version":3,"sources":["packages/practicalmeteor:mocha/lib/reporters/json-cov.js"],"names":["Base","require","exports","module","JSONCov","runner","output","call","arguments","length","self","tests","failures","passes","on","test","push","cov","global","_$jscoverage","result","map","stats","clean","process","stdout","write","JSON","stringify","ret","instrumentation","sloc","hits","misses","coverage","files","filename","Object","prototype","hasOwnProperty","data","sort","a","b","localeCompare","source","forEach","line","num","undefined","duration","currentRetry","fullTitle","title"],"mappings":"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","file":"packages/practicalmeteor:mocha/lib/reporters/json-cov.js.map","sourcesContent":["/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSONCov`.\n */\n\nexports = module.exports = JSONCov;\n\n/**\n * Initialize a new `JsCoverage` reporter.\n *\n * @api public\n * @param {Runner} runner\n * @param {boolean} output\n */\nfunction JSONCov(runner, output) {\n  Base.call(this, runner);\n\n  output = arguments.length === 1 || output;\n  var self = this;\n  var tests = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function(test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function(test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function(test) {\n    failures.push(test);\n  });\n\n  runner.on('end', function() {\n    var cov = global._$jscoverage || {};\n    var result = self.cov = map(cov);\n    result.stats = self.stats;\n    result.tests = tests.map(clean);\n    result.failures = failures.map(clean);\n    result.passes = passes.map(clean);\n    if (!output) {\n      return;\n    }\n    process.stdout.write(JSON.stringify(result, null, 2));\n  });\n}\n\n/**\n * Map jscoverage data to a JSON structure\n * suitable for reporting.\n *\n * @api private\n * @param {Object} cov\n * @return {Object}\n */\n\nfunction map(cov) {\n  var ret = {\n    instrumentation: 'node-jscoverage',\n    sloc: 0,\n    hits: 0,\n    misses: 0,\n    coverage: 0,\n    files: []\n  };\n\n  for (var filename in cov) {\n    if (Object.prototype.hasOwnProperty.call(cov, filename)) {\n      var data = coverage(filename, cov[filename]);\n      ret.files.push(data);\n      ret.hits += data.hits;\n      ret.misses += data.misses;\n      ret.sloc += data.sloc;\n    }\n  }\n\n  ret.files.sort(function(a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n\n  if (ret.sloc > 0) {\n    ret.coverage = (ret.hits / ret.sloc) * 100;\n  }\n\n  return ret;\n}\n\n/**\n * Map jscoverage data for a single source file\n * to a JSON structure suitable for reporting.\n *\n * @api private\n * @param {string} filename name of the source file\n * @param {Object} data jscoverage coverage data\n * @return {Object}\n */\nfunction coverage(filename, data) {\n  var ret = {\n    filename: filename,\n    coverage: 0,\n    hits: 0,\n    misses: 0,\n    sloc: 0,\n    source: {}\n  };\n\n  data.source.forEach(function(line, num) {\n    num++;\n\n    if (data[num] === 0) {\n      ret.misses++;\n      ret.sloc++;\n    } else if (data[num] !== undefined) {\n      ret.hits++;\n      ret.sloc++;\n    }\n\n    ret.source[num] = {\n      source: line,\n      coverage: data[num] === undefined ? '' : data[num]\n    };\n  });\n\n  ret.coverage = ret.hits / ret.sloc * 100;\n\n  return ret;\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean(test) {\n  return {\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    fullTitle: test.fullTitle(),\n    title: test.title\n  };\n}\n"]},"hash":"3f7dcd24be9e17e1b18476d3011a98054dfafcfa"}
