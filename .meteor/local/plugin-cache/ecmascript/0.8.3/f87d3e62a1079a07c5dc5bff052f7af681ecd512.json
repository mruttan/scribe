{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","filenameRelative":"packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js.map","sourceFileName":"packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"issue-1991"},"ignored":false,"code":"function MemoryLeak() {\n  this.myArr = [];\n\n  for (var i = 0; i < 1000000; i++) {\n    this.myArr.push(i);\n  }\n}\n\nvar numOfTests = 300;\n\nfor (var i = 0; i < numOfTests; i += 1) {\n  /*\n   * This Test suite will crash V8 due to:\n   * 'FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory'\n   * if all the deferred functions references have not been cleared\n   */describe('Memory Leak Suite #' + i, function () {\n    // The <closureVar> variable will be accessed by the test below.\n    // As long as those test's functions are\n    // referenced in memory, the closure variable may not be garbage collected\n    // as it is still referenced.\n    // * In a chrome heap snapshot it will appear under \"system / Context\" (a scope)\n    var closureVar;\n    before(function () {\n      var x = closureVar ? 1 : 2;\n    });\n    after(function () {\n      var x = closureVar[0];\n    });\n    beforeEach(function () {\n      var x = closureVar ? 1 : 2;\n    });\n    afterEach(function () {\n      var x = closureVar[0];\n    });\n    it('access a variable via a closure', function () {\n      // slow performance on older node.js versions\n      this.timeout(1000);\n      closureVar = new MemoryLeak();\n    });\n  });\n}","map":{"version":3,"sources":["packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js"],"names":["MemoryLeak","myArr","i","push","numOfTests","describe","closureVar","before","x","after","beforeEach","afterEach","it","timeout"],"mappings":"AAAA,SAASA,UAAT,GAAsB;AACpB,OAAKC,KAAL,GAAa,EAAb;;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,OAApB,EAA6BA,GAA7B,EAAkC;AAChC,SAAKD,KAAL,CAAWE,IAAX,CAAgBD,CAAhB;AACD;AACF;;AAED,IAAIE,aAAa,GAAjB;;AACA,KAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAIE,UAApB,EAAgCF,KAAK,CAArC,EAAwC;AACtC;;;;KAKAG,SAAS,wBAAwBH,CAAjC,EAAoC,YAAY;AAE9C;AACA;AACA;AACA;AACA;AACA,QAAII,UAAJ;AAEAC,WAAO,YAAY;AACjB,UAAIC,IAAIF,aAAa,CAAb,GAAiB,CAAzB;AACD,KAFD;AAIAG,UAAM,YAAY;AAChB,UAAID,IAAIF,WAAW,CAAX,CAAR;AACD,KAFD;AAIAI,eAAW,YAAY;AACrB,UAAIF,IAAIF,aAAa,CAAb,GAAiB,CAAzB;AACD,KAFD;AAIAK,cAAU,YAAY;AACpB,UAAIH,IAAIF,WAAW,CAAX,CAAR;AACD,KAFD;AAIAM,OAAG,iCAAH,EAAsC,YAAY;AAChD;AACA,WAAKC,OAAL,CAAa,IAAb;AACAP,mBAAa,IAAIN,UAAJ,EAAb;AACD,KAJD;AAMD,GA/BD;AAgCD","file":"packages/practicalmeteor:mocha/test/integration/fixtures/regression/issue-1991.js.map","sourcesContent":["function MemoryLeak() {\n  this.myArr = [];\n  for (var i = 0; i < 1000000; i++) {\n    this.myArr.push(i)\n  }\n}\n\nvar numOfTests = 300;\nfor (var i = 0; i < numOfTests; i += 1) {\n  /*\n   * This Test suite will crash V8 due to:\n   * 'FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory'\n   * if all the deferred functions references have not been cleared\n   */\n  describe('Memory Leak Suite #' + i, function () {\n\n    // The <closureVar> variable will be accessed by the test below.\n    // As long as those test's functions are\n    // referenced in memory, the closure variable may not be garbage collected\n    // as it is still referenced.\n    // * In a chrome heap snapshot it will appear under \"system / Context\" (a scope)\n    var closureVar;\n\n    before(function () {\n      var x = closureVar ? 1 : 2\n    });\n\n    after(function () {\n      var x = closureVar[0]\n    });\n\n    beforeEach(function () {\n      var x = closureVar ? 1 : 2\n    });\n\n    afterEach(function () {\n      var x = closureVar[0]\n    });\n\n    it('access a variable via a closure', function () {\n      // slow performance on older node.js versions\n      this.timeout(1000);\n      closureVar = new MemoryLeak();\n    });\n\n  });\n}\n"]},"hash":"f87d3e62a1079a07c5dc5bff052f7af681ecd512"}
